<drac2> # Battle Planner
args = &ARGS&
out = ""
plans=pick=""
Commands = ["view","begin","end", "delete", "clear"]
Source=get('BattlePlanLoc', 'Battles')
RBattles = load_json(get(Source, '{}'))
Battles = []
foot=f'-footer "!bplan help | Battle Source: {Source} | v1.5 Made by @Mahksad#5996"'
BP="Battle Planner"
title=f'embed -title "{BP}"'

# Assign the Mode
Mode=[x for x in args if x.lower() in Commands]
args.remove(args[0]) if args else ''

# Sort the Battles so we can get correct hits
# I hate this. We also fuzzy match in reverse
# This fixes the 'Arctic T1 82' 'Arctic T1 8' issue
if RBattles:
  Battles = list(RBattles)
  for i in range(len(Battles)-1):
    for j in range(i+1,len(Battles)):
      if Battles[i]>Battles[j]:
        temp = Battles[i]
        Battles[i] = Battles[j]
        Battles[j] = temp
  for plan in Battles:
    # Build the plan list
    plans = plans + f'`\'{plan}\'`\n'
    # if we're doing something
    # exact match check
    if args and args[0].lower() == plan.lower():
      pick=plan
    # if we're doing something
    # fuzzy match check
    # search backwards to handle 'B 8' 'B 82' issue
    elif not pick and args:
      for plan in Battles[::-1]:
        if args and args[0].lower() in plan.lower():
          pick=plan

# Check for no inputs
if not Mode or (not Mode[0] == 'new' and not Battles):
  # No battles
  if not plans:
    return (f'{title} -desc "Select a Battle Plan:\nNo Battles Found. Add one with `!denc` or manually to `!uvar {Source}`.\nAddition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}')
  else:
    return (f'{title} -desc "The Battle Planner Tool is designed for interacting with Avrae\'s Combat Initiative and simplify preparing combats.\n\nFor a list of commands see `!bplan help`\n\nSelect a Battle Plan:\n{plans}" {foot}')

elif Mode[0] == 'end':
  # End is simple, just call it
  return (f'i end')

elif Mode[0] == 'clear':
  
  if not args or not args[0]=='confirm': # Make sure 'clear confirm'
    return (f'embed -title "{BP} - Clear All Battles" -desc "You must specify a confirmation to clear all battles:\n`!bplan clear confirm`" {foot}')
  else: # Wipe out the uvar
    set_uvar(Source, "{}")
    return (f'embed -title "{BP} - Clear All Battles" -desc "All Battles Cleared. Add more with `!denc`, `!battle`, or manually to {Source}" {foot}')

elif Mode[0] == 'delete':
  if not args:
    return (f'embed -title "{BP} - Delete Battle" -desc "You must specify a Battle Name to Delete.\nSelect a Battle Plan:\n{plans}" {foot}')
  if not pick:
    return (f'embed -title "{BP} - Delete Battle" -desc "Battle `{args[0]}` Not Found\n{plans}" {foot}')
  else:
    plans = plans.replace(f'`\'{pick}\'`\n','',1)
    RBattles.pop(pick)
    set_uvar(Source, dump_json(RBattles))
    return (f'embed -title "{BP} - Delete Battle" -desc "Battle Deleted: `{pick}`\n\nRemaing Battles:\n{plans}" {foot}')

if Mode[0] == 'begin':
  if not args: # No Battle Name Provided
    return (f'embed -title "{BP} - Begin Battle" -desc "You must specify a Battle Name.\nSelect a Battle Plan:\n{plans}" {foot}')
  if not pick:  # No Plan Found
    return (f'embed -title "{BP} - Begin Battle" -desc "Battle `{args[0]}` Not Found\nSelect a Battle Plan:\n{plans}" {foot}')
  if not RBattles[pick]: # No Entries
      return (f'embed -title "{BP} - Begin Battle" -desc "__{pick}__\n\nBattle has no monsters or commands.\nAddition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}')
    
  # Handle passing additional args to !i begin
  bargs = " ".join(args)
  # Prepare the complete set of commands
  command = f'multiline\n!i begin {bargs}'
  count = total = 0
  limit = 19 # One less so we can store the more embed!
  moreSet = []
  for entry in RBattles[pick]:
    count,total = count + 1, total + 1
    if moreSet or count > limit:
      if count > limit: # We're too big, store current more and add a new more
        moreSet.append(moreCommand)      
        moreCommand = entry
      else: # Just add to the current more
        moreCommand = moreCommand + "\n" + entry
    else: # Still in size
      command = command + "\n" + entry
  # Store the More Commands if needed
  if moreSet: # TODO Build the More Embed
    moreName = f'BPlan_More_{pick}'
    set_uvar(moreName,json_dump(moreSet))
  # Call the Begin!
  return command

elif Mode[0] == 'view':
  if not args: # No Battle Name Provided
    return (f'embed -title "{BP} - Battle Viewer" -desc "You must specify a Battle Name.\nSelect a Battle Plan:\n{plans}" {foot}')
  if not pick: # No Plan Found
    return (f'embed -title "{BP} - Battle Viewer" -desc "Battle `{args[0]}` Not Found\nSelect a Battle Plan:\n{plans}" {foot}')
  if not RBattles[pick]: # No Entries
    return (f'embed -title "{BP} - Battle Viewer" -desc "__{pick}__\n\nBattle has no monsters or commands.\nAddition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}')
  # No problems, Go through the entries
  work=entryOut=effectsOut=addsOut=""
  for entry in RBattles[pick]:
    entryName = entryType = entryMod = effectName =""
    # Strip the init and type - !init <Type> <Code>
    entryType = entry.split(' ')[1]
    code=entry.replace('!init '+entryType+' ','').replace('!i '+entryType+' ','')

    # Check over the things that can add to init
    if entryType == 'madd': # madd| <name> <args>
      # Remove adv/dis from the name
      entryName = code.split(' -')[0].replace(' adv','').replace(' dis', '')
      code = code.replace(entryName+' ','')
    elif entryType == 'add': # add| <modifier> <name> <args>
      entryMod = code.split(' ')[0]
      # Take out the Type and Mod
      entryName = code.replace(entryMod+' ','').split(' -')[0]
      # and then remove adv/dis from the name
      entryName = entryName.replace(' adv','').replace(' dis', '')
      code = code.replace(entryMod+' '+entryName+' ','')     
    elif entryType == 'effect': # effect| <target> <name> <args>
      sep = effectName = ''
      # Get if we are a "Wrapped String"
      if code.split(' -')[0] == '\'':
        sep = '\''
      elif code.split(' -')[0] == '\"':
        sep = '\"'
      if sep:
        entryName = code.split(sep)[0]
      else:
        entryName = code.split(' ')[0]
      code = code.replace(sep+entryName+sep+' ','')
      # Again for the Name of the Effect
      effectName = code.split(' -')[0]
      code = code.replace(effectName+' ','')
      entryName = f'\"{entryName} ({effectName})\"' 
    elif entryType == 'note': # note| <name> <args>
      sep = effectName = ''
      # Get if we are a "Wrapped String"
      if code.split(' -')[0] == '\'':
        sep = '\''
      elif code.split(' -')[0] == '\"':
        sep = '\"'
      if sep:
        entryName = code.split(sep)[0]
      else:
        entryName = code.split(' ')[0]
      code = code.replace(sep+entryName+sep+' ','')
    elif entryType == 'opt' or entryType == 'opts': # opt,opts| <name> <args>
      entryName = code.split(' ')[0]
      code = code.replace(entryName+' ','')
    #elif entryType == 'meta' or entryType == 'metaset': # meta,metaset| <args>
      #Do Nothing here
    else: # skip the rest for now
      continue
    # Argparse it
    work = argparse(code)
    # Handle multiple number and group
    entryName = entryName + (' (x'+work.last('n',None,str)+')' if work.get('n') else '') + (' ['+work.last('group')+']' if work.get('group') else '')

    if entryType == 'madd':
      if not entryOut:
        entryOut = "\n**--Monsters--**"
      # Get all the madd
      opts = ("-name: "+ work.join('name'," ") if work.get('name') else '') + ("-h" if work.get('h') else '') + (("dis" if work.adv()==-1 else "adv" if work.adv()==1 else '') if work.adv() else '') + ("-b: "+ work.last('b',None,str) if work.get('b') else '') + ("-p: "+ (work.last('p',None,str) if not entryMod else str(entryMod)) if work.get('p') else '') + ("-hp: "+ work.last('hp',None,str) if work.get('hp') else '') + ("-thp: "+ work.last('thp',None,str) if work.get('thp') else '') + ("-ac: "+ work.last('ac',None,str) if work.get('ac') else '') + ("-immune: "+ work.last('immune') if work.get('immune') else '') + ("-resist: "+ work.last('resist') if work.get('resist') else '') + ("-vuln: "+ work.last('vuln') if work.get('vuln') else '') + ("-rollhp" if work.get('rollhp') else '') + ("-note: "+ work.join('note'," ") if work.get('note') else '')
      # Store the results
      entryOut = entryOut + f'\n• **{entryName}**' + (f'\n{opts} ' if opts else '')

    elif entryType == 'add':
      if not addsOut:
        addsOut = "\n**--Adds--**"
      # Get all the add
      opts = ("-controller: "+ work.last('controller') if work.get('controller') else '') + ("-h" if work.get('h') else '') + (("dis" if work.adv()==-1 else "adv" if work.adv()==1 else '') if work.adv() else '') + ("-p: "+ (work.last('p',None,str) if not entryMod else str(entryMod)) if work.get('p') else '') + ("-hp: "+ work.last('hp',None,str) if work.get('hp') else '') + ("-thp: "+ work.last('thp',None,str) if work.get('thp') else '') + ("-ac: "+ work.last('ac',None,str) if work.get('ac') else '') + ("-immune: "+ work.last('immune') if work.get('immune') else '') + ("-resist: "+ work.last('resist') if work.get('resist') else '') + ("-vuln: "+ work.last('vuln') if work.get('vuln') else '') + ("-note: "+ work.join('note'," ") if work.get('note') else '') 
      # Store the results      
      addsOut = addsOut + f'\n• **{entryName}**' + (f'\n{opts} ' if opts else '')
      
    elif entryType == 'effect':
      # Add the Effects Header
      if not effectsOut:
        effectsOut = "\n**--Effects--**"
      # Get all the effect
      opts = ("-parent: "+ work.join('parent'," ") if work.get('parent') else '') + ("conc: True" if work.get('conc') else '') + ("-t: "+ work.join('t',", ") if work.get('t') else '') + ("-attack: "+ work.join('attack'," ") if work.get('attack') else '') + ("-ac: "+ work.last('ac',None,str) if work.get('ac') else '') + ("-sb: "+ work.last('sb',None,str) if work.get('sb') else '') + ("-b: "+ work.last('b',None,str) if work.get('b') else '') + ("-d: "+ work.last('d',None,str) if work.get('d') else '') + ("-dur: "+ work.last('dur',None,str) if work.get('dur') else '') + ("end: True " if work.get('end') else '') + ("-immune: "+ work.last('immune') if work.get('immune') else '') + ("-resist: "+ work.last('resist') if work.get('resist') else '') + ("-neutral: "+ work.last('neutral') if work.get('neutral') else '') + ("-vuln: "+ work.last('vuln') if work.get('vuln') else '')
      # Store the results
      effectsOut = effectsOut + f'\n• **{entryName}**' + (f'\n{opts} ' if opts else '')

  return (f'embed -title "{BP} - Battle Viewer" -desc "__{pick}__'+(f'{entryOut}' if entryOut else '')+(f'\n{addsOut}' if addsOut else '')+(f'\n{effectsOut}' if effectsOut else '')+f'" {foot}')


elif Mode[0] == 'new':
  if not args: # No Battle Name Provided
    return (f'embed -title "{BP} - Battle Creator" -desc "You must specify a Battle Name to create a battle.\nExisting Battle Plans:\n{plans}" {foot}')
  if pick: # No Plan Found
    return (f'embed -title "{BP} - Battle Creator" -desc "You have entered an existing battle plan. Did you mean `add`, `remove`, or `edit`?\n\n__{pick}__\nExisting Battle Plans:\n{plans}" {foot}')
  else: # We've got a new battle, name it.
    BName = args[0]
    args.remove(args[0])
    bargs = " ".join(args)
    if args: # TODO Add the actual Args
      code= f'\"{BName}\": [{bargs}]'
    else: # Empty Battle. Make and Mention.
      code= f'\"{BName}\": []'
      outBattles = dump_json(RBattles)
    # Ready to Store the Battle
    if outBattles[-2]==']': # Adding to an existing Source
        outBattles=outBattles.replace("]}","], "+(code)+"}", 1)
        set_uvar(Source, outBattles)
    else: # Adding to an empty Source
        set_uvar(Source, "{"+code+"}")
    return (f'embed -title "{BP} - Battle Creator" -desc "__{BName}__\n\nBattle created without monsters. Use `add` to add in monsters." {foot}')
</drac2>
