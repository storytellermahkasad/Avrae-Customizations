<drac2> # Battle Planner
args = &ARGS&
origArgs = """&*&"""
strArgs = """&*&"""

# Alias Generic Variables
AuthorName = 'Mahkasad#5996'
AliasName = 'Battle Planner'
Top_OptionsVarName = 'BattleToolOptions'
OptionsVarName = 'BattlePlanner'
LoadCheckName = 'BattleToolsLoadCheck'
AliasPrefix = ctx.prefix
AliasCommand = ctx.prefix+ctx.alias
versionNumner = "2.65"
version = "v"+versionNumner

#Alias Specific Variables
# I hate it, but double-escape it keeps it functional
newLine, sep, sepSingle, sepSlash, sepSingleSlash, openBrace, closeBrace, slash, pipeSlash, fancyLeft, fancyRight, fancySingle ="\n",'\"','\'','\\\"', '\\\'', '{', '}', '\\', '\|','“','”','’'

Mode = Display = PlanList = WPlanList = Pick = TryPick = ''
Fuzzy = False
OptionsVar,RBattles, WBattles, RBattlePlans = load_json('{}'),load_json('{}'), load_json('{}'), load_json('[]')

# Options
OptionsDefault = {
  "SourceLocation": ["Battles"],
  "OutputLocation": "Battles",
  "MoreOutputLocation": "BattlesBeginMore",
  "PageCacheOutput": "BattlePlannerCache",
  "ViewOverride": "None",
  "MapAttach": "DM",
  "AttachInit": 20 }
# Handle options that take lists
OptionsLists = ["SourceLocation"]
# Handle options with specific choices
OptionsFixed = {
  "ViewOverride": ["none", "view-pretty", "view-numeric"],
  "MapAttach": ["DM", "Map", "Lair"] }
# The Descriptions of Each Option
# CodeName, ShortName, Valid Type, Description
OptionsDesc = {
  "SourceLocation": ["Source", "List of any UVAR|CVAR|SVAR `*`", "Where to load the Battle Plan List. Each source can be a list of GVARs"],
  "OutputLocation": ["Output", "Any Single UVAR|CVAR `*`", "Where to store the Battle Plan List."],
  "MoreOutputLocation": ["More", "Any Single UVAR `*`", "Where to store the begin commands cache."],
  "PageCacheOutput": ["Page", "Any Single UVAR `*`", "Where to store the page cache"],
  "ViewOverride": ["View", "Fixed Value", "The viewmode to force."],
  "MapAttach": ["Attach", "Fixed Value", "Map Attachment name to use."],
  "AttachInit": ["Init", "Any Integer", "The initiative count to place the Map Attach."] }

# Set Lists
Commands = ["view","begin", "end", "delete", "clear", "new", "rename", "add", "remove", "edit", "export", "move", "more", "p", "n", "options", "map"]
# Lists for specific fixed options
argNamesSingle = ["ac","controller","desc","dur","hp","max","name","note","parent","thp"]
argNamesSpecial = ["conc","end","h","rollhp"]
argNamesMulti = ["attack","b","d","immune","neutral","resist","sb","t","vuln"]
argNamesMeta = ["dyn", "turnnotif", "deathdelete"]
argDescMeta = {
  "dyn": "Dynamic initiative; Rerolls all initiatves at the start of a round",
  "turnnotif": "Notifies the controller of the next combatant in initiative",
  "deathdelete": "Toggles removing monsters below 0 HP" }
argDescMap = {
  "options": ("Options",""),
  "objects": ("Objects","/"),
  "walls": ("Walls","/"),
  "fow": ("FOW",","),
  "json": ("JSON",",") }

argSingleDescMap = {
  "bg": "Background",
  "mapsize": "Size",
  "view": "View" }

# Error Catching
set_uvar(LoadCheckName,int(get(LoadCheckName,-1))+1)

# Fixed Strings
Foot = f"-footer '{AliasCommand} help | {version} Made by {AuthorName}'"
HelpCommand = f"For a list of commands see `{AliasCommand} help`"
# Fixed JSON
TopOptEmpty = load_json('{'+f'"{Top_OptionsVarName}": {openBrace+closeBrace}'+'}')
OptEmpty = '{'+f'"{OptionsVarName}": {openBrace+closeBrace}'+'}'

if args: # Fall Back Commands - In case someone screws up
  if args[0].lower() == 'fix':
    delete_uvar(LoadCheckName) # Success Loading
    return (f"""embed -title '{AliasName} - Fix' -desc "The {AliasName} Tool Load Check has been fixed.

    {HelpCommand}"  """)
  elif args[0].lower() == 'reset':
    TopOptionsVar = load_json(get(Top_OptionsVarName, TopOptEmpty))
    TopOptionsVar.update(load_json(OptEmpty))
    set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))
    delete_uvar(LoadCheckName) # Success Loading

    return (f"""embed -title '{AliasName} - Reset' -desc "The {AliasName} Tool has done a reset of the `{OptionsVarName}` portion of the `{Top_OptionsVarName}` uvar. This should be done if the load uvars have been corrupted.

    If the problem persists try doing a `{AliasPrefix}uvar delete {Top_OptionsVarName}` or contact me on my Discord.
    {HelpCommand}" {Foot}""")
  elif args[0].lower() == 'clear':
    TopOptionsVar = load_json(get(Top_OptionsVarName, TopOptEmpty))
    OptionsVar = TopOptionsVar.get(OptionsVarName, load_json(OptEmpty))

    OutputName= OptionsVar.get('OutputLocation', OptionsDefault['OutputLocation'])
    if not len(args) > 1 or not args[1]=='confirm': # Make sure 'clear confirm'
      return (f"""embed -title '{AliasName} - Clear All Output Battle Plans' -desc "You must specify a confirmation to clear all `{OutputName}` battles:
      `{AliasCommand} clear confirm`" {Foot}""")
    else: # Wipe out the uvar
      set_uvar(OutputName, "{}")
      delete_uvar(LoadCheckName) # Success Loading
      return (f"""embed -title '{AliasName} - Clear All Plans' -desc "All Battle Plans in `{OutputName}` cleared. Add more with `{AliasCommand} new`" {Foot}""")
  if '“' in strArgs or '”' in strArgs or '’' in strArgs:
    FullCommand = f"""{AliasCommand}{' '+origArgs if origArgs else ''}"""
    CodeAttempted = f"Attempted:{newLine}```{newLine+FullCommand+newLine}```"

    return (f"""embed -title '{AliasName} - Fancy Quotes' -desc "Found Fancy or Smart Quotes `{fancyLeft} {fancyRight} {fancySingle}` in command.
    Please replace them with `{sepSlash} {sepSlash}` or `{sepSingle} {sepSingle}`.

    On iOS (and probably some Android keyboards), there is a setting for 'Smart Punctuation'. While it does make your quotes look nicer, it unfortunately can break some things when aliasing, as they are not what the code expects. Here is a recording on how to disable it on iOS. (Special Thanks to Riptidecord#7191 for the recording.)
    
    {CodeAttempted}" -image 'https://cdn.discordapp.com/attachments/583123959097196545/755244715707858984/ezgif-6-3ead168dc0bf.gif' {Foot}""")


if int(get(LoadCheckName)) > 2: # If we get here and have already failed, then help message
  return (f"""embed -title '{AliasName} - Failed to Load' -desc "The {AliasName} Tool has failed to load more than once.
  This can happen because of a mangled battle plan or options var.

  If you are unsure what has happened try the following:

  **Check the Output File:**
    `{AliasPrefix}uvar {OptionsDefault['OutputLocation']}` - If you set a custom Output, change the name to that
    If the file looks incorrect it will need to be fixed.

  **If you are unsure how to fix the output file:**
    `{AliasCommand} clear confirm` - This will clear the Output file

  **If the problem persists:**
    `{AliasCommand} reset` - This will reset the Options file

  **Advanced Users:**
    Ensure that your input sources are correct.
    If you modify something manually be sure to do `{AliasCommand} fix`
    This will clear the failed load flag.

  If the problem still persists try doing a `{AliasPrefix}uvar delete {Top_OptionsVarName}`
  or contact me on my Discord (found in `{AliasCommand} help`).
  {HelpCommand}" {Foot}""")

# We've passed the first load in check
# Load the Options
TopOptionsVar = load_json(get(Top_OptionsVarName, OptEmpty))
OptionsVar.update(OptionsDefault)
OptionsVar.update(load_json(dump_json(TopOptionsVar.get(OptionsVarName, '{}'))))
# Load in the values by name
SourceName = OptionsVar.get('SourceLocation')
OutputName = OptionsVar.get('OutputLocation')
MoreOutputName= OptionsVar.get('MoreOutputLocation')
CacheOutputName = OptionsVar.get('PageCacheOutput')
ViewOverride = OptionsVar.get('ViewOverride')
MapAttach = OptionsVar.get('MapAttach')
AttachInit = OptionsVar.get('AttachInit')

# Load the values that are stored as a varname
MoreOutput= get(MoreOutputName)
CacheOutput = get(CacheOutputName)

# Handle issues with values
# This covers None failing to match
if ViewOverride and ViewOverride.lower() == 'none':
 ViewOverride = None

if not TopOptionsVar.get(OptionsVarName): # If they don't already have options, save them
  # Save to Top then save out Top
  TopOptionsVar.update(load_json('{'+f'"{OptionsVarName}": {dump_json(OptionsVar)}'+'}'))
  set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))

# TODO: #1 Swap to loading names only to prevent Too Big error
for var in SourceName: # Load Sources
  # Single gvar
  if get_gvar(var):
    RBattles.update(load_json(get_gvar(var)))
  # Server Var
  if (currVar := get_svar(var)):
    jsonVar = load_json(currVar) or None
    if typeof(jsonVar) == 'SafeList': # Is gvar List
      for gvar in jsonVar:
        if get_gvar(gvar):
          RBattles.update(load_json(get_gvar(gvar)))
    elif get_gvar(jsonVar): # Single Gvar
      RBattles.update(load_json(get_gvar(jsonVar)))
    else: # Single Var
      RBattles.update(load_json(currVar))
   # User/Char Var
  if (currVar := get(var)):
    jsonVar = load_json(currVar) or None
    if typeof(jsonVar) == 'SafeList': # Is gvar List
      for gvar in jsonVar:
        if get_gvar(gvar):
          RBattles.update(load_json(get_gvar(gvar)))
    elif get_gvar(jsonVar): # Single Gvar
      RBattles.update(load_json(get_gvar(jsonVar)))
    else: # Single Var
      RBattles.update(load_json(currVar))
  # Failed to load it, pretend it's not there
# Load the Output
WBattles.update(load_json(get(OutputName,'{}')))

# Assign the Mode
if args:
  m = args.pop(0)
  strArgs = strArgs.replace(m,'',1).lstrip()
  # Do exact and then fuzzy match on commands
  Mode = [x for x in Commands if m.lower() == x]
  if not Mode:
    Mode = [x for x in Commands if m.lower() in x]
  if Mode:
    Mode = Mode[0]

if not (Mode=='p' or Mode=='n'): # Delete the Cache
  delete_uvar(CacheOutputName)

if args: # Pull out what is being tried
  TryPick = args.pop(0)
  for begins in [TryPick, f"\"{TryPick}\"", f"\'{TryPick}\'"]:
    if strArgs.startswith(begins):
      strArgs = strArgs.replace(begins,'',1).lstrip()
      break
  TryPick = TryPick.lower()
if RBattles: # Sort the Plans so we can get correct hits
  # I hate this. We also fuzzy match in reverse
  # This fixes the 'Arctic T1 82' 'Arctic T1 8' issue
  RBattlePlans = list(RBattles)
  RBattlePlans.sort()
  for plan in RBattlePlans:
    # Build the plan list
    PlanList += f"{newLine}`'{plan.title()}'`"
    # if we're doing something
    # exact match check
    if TryPick and TryPick == plan.lower():
      Pick = plan
  # if we're doing something
  # fuzzy match check
  # search backwards to handle 'B 8' 'B 82' issue
  if not Pick:
    for plan in RBattlePlans[::-1]:
      if TryPick and TryPick in plan.lower():
        Pick = plan
        Fuzzy = True
if WBattles: # Generate Working Battle List
  WBattlePlans = list(WBattles)
  WBattlePlans.sort()
  for plan in WBattlePlans:
    # Build the plan list
    WPlanList += f"{newLine}`'{plan.title()}'`"

# If we got to here, then they've loaded.
delete_uvar(LoadCheckName) # Success Loading - Clear the error checker

# Embed Ready
desc = commandList = examples = selectIntruction = pagingInfo = ""
title = AliasName+(" - "+Mode.title() if Mode else '')
body = ""

# Fixed Strings
FullCommand = f"""{AliasCommand}{' '+origArgs if origArgs else ''}"""
CodeAttempted = f"Attempted:{newLine}```{newLine+FullCommand+newLine}```"
Foot = f""" -footer '{AliasCommand} help | Source: [{SourceName[0] if len(SourceName)==1 else ",".join(SourceName)}]{' | Output:['+OutputName+']' if not OutputName == ",".join(SourceName) else ''} | {version} Made by {AuthorName}' """

#Fixed Selects
SelectPlanInstruct = f"Select a Battle Plan:{PlanList}"
SelectPlanEdit = f"Select a Battle Plan to edit:{PlanList}"
SelectWorkingSource = f"Working Source Plans:{(WPlanList if WPlanList else '`None Stored`')}"

if not Mode and PlanList: # Check for no inputs
  desc = f"The Battle Planner Tool is designed for interacting with Avrae's Combat Initiative and simplify preparing combats.{newLine+newLine+HelpCommand+newLine}To view a battle plan use: `"+AliasCommand+" view <battlename>`"
  examples = ""
  selectIntruction = SelectPlanInstruct
  Display = ViewOverride if ViewOverride else 'view-pretty'
  # handle bad mode
  if not TryPick:
    CodeAttempted = ""
  else:
    Commands.sort()
    desc += f"""{newLine+newLine}Select a Valid Command:
    {", ".join([f'`{x}`' for x in Commands])}"""
    TryPick = Pick = selectIntruction = ""

# Fixed Strings
ModeCommand = f"{AliasCommand} {Mode}"
MultiSourceError = f"""Cannot {Mode} to `{Pick}`:
_Mult-Source View is an advanced feature._

Battle Plans cannot be edited unless stored in Output: `{OutputName}`
To change the Output: `{AliasCommand} options`"""
MapTextHelper = f"""Using `set` alone adds the Attach ({MapAttach}) for the `{AliasPrefix}map` command.
You can add other arguments to assign map information:
{newLine.join(x for x in ["`[-bg <url link>]` `*`", "`[-mapsize <XxY size>]` `*^`", "`[-view <view>]` `*`", "`[-options <options>]`", "`[-objects <objects>]`", "`[-walls <walls>]`" ,"`[-fow <fow>]`", "`[-json <json>]`"])}

**Note:**
**`^` Indicates this value is required!**
**`*` Indicates only the last value will be used.**

It is recommended you use `{AliasPrefix}map status export` to see a full list of your map settings at the bottom. Do not include the `{AliasPrefix}map` portion."""

# Fixed Errors
EditNewError = f"Plan `{TryPick.title()}` not found.{newLine}Did you mean `new`?"
EditAddError = f"Plan `{TryPick.title()}` is empty.{newLine}Did you mean `add`?"

# Example Edits
ExampleSimple = f"{ModeCommand} \\\"Example Battle\\\""
ExamplesBase = ["!i madd Ogre -n 2", "!i madd \\\"Ancient Black Dragon\\\"", "!i effect OG1 bulk -ac +10", "!i meta -name \\\"Boss Battle 2\\\""]
ExamplesRename = ["Battle2","\\\"Super Cool Battle\\\""]


if not PlanList and not (Mode == 'new' or Mode == 'options'): # No battles
  title = AliasName
  desc = f"No Battle Plans Found. Add one with `{AliasCommand} new`, `{AliasPrefix}denc`, or manually to: `{AliasPrefix}uvar {','.join(SourceName)}`.{newLine+newLine+HelpCommand}"

  Display = ViewOverride if ViewOverride else 'view-pretty'

elif Mode == 'options':
  # We clear this if we succeed
  examples = f"""Examples:
  `{ModeCommand} View pretty` - Set an option
  `{ModeCommand} Source Battles Battles2` - Set an option that uses a list
  `{AliasCommand} Source default` - For restoring a default option
  `{AliasCommand} reset` - For restoring all defaults"""

  newOption = ""
  if not TryPick: # Just print them out
    desc=f"Loaded options for the {AliasName}.{newLine}To Change an option select the name and new command.{newLine}See examples for more."
    CodeAttempted = ""
  else: # We're trying to make a change
    opt = [x for x in OptionsVar.keys() if TryPick.lower() == x.lower()]
    if not opt: # Failed Exact, try Fuzzy
      opt = [x for x in OptionsVar.keys() if TryPick.lower() in x.lower()]
    if opt and args: # Don't change unless we've got something to change to
      opt = opt[0]
      if strArgs == 'default': # Check if we want to Default
        newOption = OptionsDefault[opt]
      elif opt in OptionsFixed.keys(): # Check if we're a fixed option
        optionTry = args.pop(0)
        strArgs.replace(str(optionTry),'',1).lstrip()
        fixedOption = [x for x in OptionsFixed[opt] if optionTry.lower() in x.lower()]
        if fixedOption: # Found it, assign
          newOption = fixedOption[0]
      elif opt in OptionsLists: # Check if we're an option that wants lists
        newOption = args
      else: # Just a normal option
        newOption = strArgs
      if newOption: # Fail Check - If we exist we are assigning now
        OptionsVar[opt] = newOption
        desc = f"Option: `{opt}` assigned to: `{newOption}`"
        examples = CodeAttempted = "" # Wipe These on success
        #Save to Top then save Top
        TopOptionsVar.update(load_json('{'+f'"{OptionsVarName}": {dump_json(OptionsVar)}'+'}'))
        set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))

    if not newOption: # Didn't find an option
      desc="Failed to find that option or provide a new setting."+newLine+"To Change an option select the name and new command."
  # Show the current option values
  optionsBody = newLine.join([f"**{x}**: `{OptionsVar[x]}`"+(f" | Default: `{OptionsDefault[x]}`" if not OptionsVar[x] == OptionsDefault[x] else '') for x in OptionsVar.keys()])
  # Build the option descriptions
  optionsText = "**Option Info:**"+newLine
  if not newOption: # Only show the full info if we've not changed anything
    optionsText += newLine.join([f"`{OptionsDesc[x][0]}`: {OptionsDesc[x][1]+newLine}-{OptionsDesc[x][2]}"+(newLine+"--_Valid Options_ - `"+"` | `".join(y for y in OptionsFixed[x])+"`" if x in OptionsFixed else '')+newLine for x in OptionsDesc])
  else:
    optionsText += f"`{OptionsDesc[opt][0]}`: {OptionsDesc[opt][1]+newLine}-{OptionsDesc[opt][2]}"+(newLine+"--_Valid Options_ - `"+"` | `".join(y for y in OptionsFixed[opt])+"`" if opt in OptionsFixed else '')+newLine
  optionsText += newLine+"_Options with a * are Case Sensitive_"

  return f"""embed -title "{title}" -desc "{desc}{newLine+CodeAttempted if CodeAttempted else ''}{newLine+newLine+optionsBody}{newLine+newLine+optionsText if optionsText else ''}{newLine+newLine+examples if examples else ''}" {Foot}"""

elif Mode == 'end':
  # End is simple, just call it
  return ("""i end""")

elif Mode == 'begin':
  # Used by All
  examples = f"`{ExampleSimple} <init args>`"

  selectIntruction = SelectPlanInstruct
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # No Plan Name Provided
    desc = "You must specify a Plan Name."
  elif not Pick:  # No Plan Found
    desc = f"Plan `{TryPick.title()}` Not Found"
  elif not RBattles[Pick]: # No Entries
    desc = f"Plan `{Pick}` has no monsters or commands."
  else: # No errors, prepare commands
    # Handle passing additional args to i begin
    bargs = " ".join(args)
    # Prepare the complete set of commands
    multiCommand = f"""multiline{newLine}"""
    command = f"""{AliasPrefix}i begin {bargs}""" if not combat() else ""
    count,total,moreCount = 2,0,1 # Two less so we can store the more embed
    limit = 20
    moreSet = load_json('[]')
    MoreBattles = load_json('{}')
    output=""
    for entry in RBattles[Pick]:
      count,total = count + 1, total + 1
      if moreSet or MoreBattles or count > limit:
        if not moreSet: # FirstTime for this more, hit on count
          if len(RBattles[Pick])-total == 0: # We fit in if no more embed
            command += newLine + entry.replace(entry[0],AliasPrefix)
          else: # Otherwise, start the more
            count = 2
            moreSet.append(entry)
        elif count > limit: #Over limit
          if len(RBattles[Pick])-total == 0:
            moreSet.append(entry)
          else:
            MoreBattles.update(load_json('{'+f'"{plan+str(moreCount)}": {dump_json(moreSet)}'+'}'))
            moreSet, count = load_json('[]'), 1
            moreCount += 1
            moreSet.append(entry)
        else: # Regular, store
          moreSet.append(entry)
      else: # Still in size
        command += newLine + entry.replace(entry[0],AliasPrefix)
    if MoreBattles or moreSet: # Store the More Commands if needed
      if moreSet: # Final entry store
        MoreBattles.update(load_json('{'+f'"{plan+str(moreCount)}": {dump_json(moreSet)}'+'}'))
      MoreBattles["timer"] = int(time()) + 20
      MoreBattles["commandCount"] = total - 19

      set_uvar(MoreOutputName,dump_json(MoreBattles))
      # Append the More Dialog
      moreEmbed = (f"""{AliasPrefix}embed -title "{AliasName} - More Commands" -desc "More Commands has been used due to there being more than `20` commands. (This includes `{AliasPrefix}i begin` and this message). When the current batch of commands finishes, call `{AliasCommand} more` to continue adding to initiative. There are `{MoreBattles["commandCount"]}` more commands in `{len(MoreBattles)-2}` batches." {Foot}""")
      multiCommand += moreEmbed + newLine
    # Call the Begin
    return multiCommand + command # moreEmbed[1:] #

elif Mode == 'more':
  # Read the More
  MoreBattles = load_json(get(MoreOutputName, '{}'))
  if not MoreBattles: # Handle Empty
    return (f"""embed -title "{AliasName} - More Battle" -desc "There is not currently more battle plan to add to Initiative.{newLine}Did you mean `{AliasCommand} begin`? {CodeAttempted}" {Foot}""")
  if int(MoreBattles.timer) > int(time()): #Still on Cooldown
    return (f"""embed -title "{AliasName} - More Battle" -desc "The `multiline` command is on cooldown for: `{int(MoreBattles.timer) - int(time())}` seconds. Please wait before calling {Mode} again.
    {newLine}There are `{MoreBattles.commandCount}` more commands in `{len(MoreBattles)-2}` batches." {Foot}""")

  # Take out the admin stuff
  MoreBattles.pop("timer")
  prior = MoreBattles.pop("commandCount")
  # Get the keys in a list
  entries = list(MoreBattles.keys())[0]
  command = f"""multiline{newLine}"""
  current = MoreBattles.pop(entries)
  command += newLine.join(current)
  # Call the commands
  if MoreBattles: # More more remains
    moreEmbed = (f"""{newLine}{AliasPrefix}embed -title "{AliasName} - More Commands" -desc "Commands Remain: `{newLine.join(MoreBattles.keys())}`" {Foot}""")
    MoreBattles["timer"] = time() + 20
    MoreBattles["commandCount"] = prior - len(current)
    command += moreEmbed
    set_uvar(MoreOutputName,dump_json(MoreBattles))
  else:
    set_uvar(MoreOutputName,'{}')
  return command # moreEmbed[1:] #

elif Mode == 'new':
  # Cover Output that's always true
  examples = newLine.join([f"`{ExampleSimple} {x}`" for x in ExamplesBase])
  selectIntruction = f"Existing Battle Plans:{PlanList}"
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to make a new plan."
  elif Pick and not Fuzzy: # Plan already exists and is exact
    desc = f"Plan `{TryPick.title()}` already exists.{newLine}Did you mean `add`, `remove`, `move`, `rename`, or `edit`?"
  else: # We've got a new battle, name it.
    BName = TryPick.strip('\'\"\\\"')
    # Do the replace
    editBattles = load_json('[]')
    # Split the lines to get all our commands!
    commandList = strArgs.splitlines()
    # Iterate over the lines
    for line in commandList:
      line = line.strip()
      # Handle the value starting with a quote we missed
      if line[0] == '\"':
        line = line.replace('\"','',1)
        line = line[::-1].replace('\"','',1)[::-1]
      editBattles.append(line)
    # Store and Save
    WBattles.update(load_json('{'+f'"{BName}": {dump_json(editBattles)}'+'}'))
    RBattles.update(load_json('{'+f'"{BName}": {dump_json(editBattles)}'+'}'))
    # Save out
    set_uvar(OutputName, dump_json(WBattles))
    Pick = BName
    # Output Build
    if not args:
      desc = f"Battle __{Pick.title()}__ Created without monsters. Use `add` to add in monsters."
    else:
      desc = f"Battle __{Pick.title()}__ Created with entry: `{strArgs.replace(sep,sepSlash)}`"
    # Wipe because we succeded
    CodeAttempted = ""
    examples = ""
    selectIntruction = ""

elif Mode == 'delete':
  # Output things used by all
  examples = f"`{ExampleSimple}`"
  selectIntruction = SelectWorkingSource
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # Put nothing -- TUTORIAL HERE
    desc = "You must specify a Plan Name to Delete."
  elif Pick:
    # Go through all the entered options
    # Split the lines to get all our commands!
    deleted = currPick = ""
    Failed = False
    commandList = strArgs.splitlines()
    commandList.insert(0, TryPick)
    # Iterate over the lines
    for line in commandList:
      line = line.strip('\'\" ')
      for plan in WBattlePlans: # exact match check
        if line.lower() == plan.lower():
          currPick = plan
      # if we're doing something
      # fuzzy match check
      # search backwards to handle 'B 8' 'B 82' issue
      if not currPick:
        for plan in WBattlePlans[::-1]:
          if line.lower() in plan.lower():
            currPick = plan
            Fuzzy = True
      if currPick:
        WBattles.pop(currPick)
        # RBattles.pop(Pick) # We don't do this so we can display what was deleted
        WBattlePlans.remove(currPick)
        WPlanList = WPlanList.replace(f"{newLine}`'{currPick.title()}'`",'',1)
        deleted += newLine+f"`{currPick.title()}`"
        currPick = ""
      else:
        Failed = True
        break
    # Report Results
    if deleted: # If we actually made changes save them and rebuild the list
      set_uvar(OutputName, dump_json(WBattles))
      selectIntruction = f"Working Source Plans:{(WPlanList if WPlanList else '`None Stored`')}"
    if not Failed:
      examples = ""
      CodeAttempted = ""
    desc = f"{'Battle Plans Deleted: '+deleted if deleted else ''}"+(f"{newLine+newLine}**Failed to Find in Output - `{OutputName}`:**{newLine}`{line.replace(sep,sepSlash)}`" if Failed else '')
    # Clear these because success

    if len(commandList) > 1:
      TryPick = Pick = ""

elif Mode == 'rename':
  # Cover Output that's always true
  examples = newLine.join([f"`{ExampleSimple} {x}`" for x in ExamplesRename])
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to rename a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, rename it.
    if not args: # You must have more to get here. No adding empty
      desc = "You must specify a new name to rename a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = MultiSourceError
        selectIntruction = SelectWorkingSource
        examples = ""
      else:
        # Ready to Store the Modified Battle
        strArgs = strArgs.strip(sepSingle+sepSlash+sep)
        editBattles = WBattles[Pick]
        WBattles.pop(Pick)
        RBattles.pop(Pick)
        WBattles.update(load_json('{'+f'"{strArgs}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{strArgs}": {dump_json(editBattles)}'+'}'))
        # Save out
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = f"Renamed Battle from:{newLine}`{Pick.title()}` => `{strArgs.title()}`"
        Pick = strArgs
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'add':
  # Cover Output that's always true
  examples = newLine.join([f"`{ExampleSimple} {x}`" for x in ExamplesBase])
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, add to it.
    if not args: # You must have more to get here. No adding empty
      desc = "You must specify a command to add to a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = MultiSourceError
        selectIntruction = SelectWorkingSource
        examples = ""
      else: # Ready to Store the Modified Battle
        editBattles = WBattles[Pick]
        # Split the lines to get all our commands!
        commandList = strArgs.splitlines()
        # Iterate over the lines
        for line in commandList:
          line = line.strip()
          # Handle the value starting with a quote we missed
          if line[0] == sep:
            line = line.replace(sep,'',1)
            line = line[::-1].replace(sep,'',1)[::-1]
          editBattles.append(line)
        # Store and Save
        WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        # Save out
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = f"__{Pick.title()}__: Added entry `{strArgs.replace(sep,sepSlash)}`"
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'export':
  # Cover Output that's always true
  title = AliasName+" - Plan "+Mode.title()

  examples = f"`{ExampleSimple}`"
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = "Select a Battle Plan to Export:"+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to export a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing plan, Output it
    exportBattle = RBattles[Pick]
    command = f"```{newLine+AliasCommand} new {Pick}"
    # Iterate over the commands
    for comm in exportBattle:
      command += newLine + comm.replace(comm[0],AliasPrefix)

    # Output the Plan
    if args and 'mobile' in args:
      # Mobile-Friendly Mode
      title += " - Mobile Mode"
    else:
      desc = "Exporting Plan `"+Pick+"`. Add `mobile` for an easier phone copy."+newLine+"To duplicate the plan copy paste the following block:"+newLine
    desc += command+newLine+"```"
    return (f"""embed -title '{title}' -desc '{desc}' {Foot}""")

elif Mode == 'edit':
  # Cover Output that's always true
  examples = newLine.join([f"`{ExampleSimple} 1 {x}`" for x in ExamplesBase])
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = EditAddError
  elif not Pick in WBattles: # Editing with Multi-Source
    # Output Build
    desc = MultiSourceError
    selectIntruction = SelectWorkingSource
    examples = ""
  else: # We've got an existing battle, edit it.
    editBattles = RBattles[Pick]
    # Split the lines to get all our commands!
    commandList = strArgs.splitlines()
    commandsMod = ""
    Edited = False
    Failed = False
    # Iterate over the lines
    for line in commandList:
      if not len(args) > 1 or not args[0].isdigit(): # You must have more to get here. No adding empty
        desc = "You must specify a numbered command to edit and a new command to edit a plan."
        selectIntruction = ""
        Failed = True
        break
      else:
        # Ready to Modify the selected entry
        largs = line.split(' ')
        selected = int(largs.pop(0)) if largs[0].isdecimal() else None
        strArgs = line.replace(str(selected),'',1).lstrip()
        if selected == None or selected < 0 or selected > len(editBattles)-1: # Not enough info provided
          desc = "You must specify a numbered command to move and a numbered new position to edit a plan."
          selectIntruction = ""
          Failed = True
          break
        # Do the replace
        entry = editBattles[selected]
        strArgs = strArgs.strip()
        if strArgs[0] == sep:
          strArgs = strArgs.replace(sep,'',1)
          strArgs = strArgs[::-1].replace(sep,'',1)[::-1]
        editBattles[selected] = strArgs
        commandsMod+= f"{newLine}`{str(selected)}`: `{entry.replace(sep,sepSlash)}` => `{strArgs.replace(sep,sepSlash)}`"
        Edited = True
    if Edited:
      # Store and Save
      WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
      RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
      set_uvar(OutputName, dump_json(WBattles))
      # Output Build
      desc = f"Commands Modified:{commandsMod}"+(f"{newLine+newLine}**Failed to complete Properly:** `{newLine+line.replace(sep,sepSlash)}`" if Failed else '')
      # Wipe because we succeded
      if not Failed:
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'remove':
  # Cover Output that's always true
  examples = f"`{ExampleSimple} 1` to remove command `1`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = EditAddError
  else: # We've got an existing battle, modify it.
    editBattles = RBattles[Pick]
    if not args or not args[0].isdigit() or int(args[0]) > len(editBattles)-1: # Check Args
      desc = "You must specify a numbered command to remove an entry in a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = MultiSourceError
        selectIntruction = SelectWorkingSource
        examples = ""
      else: # Ready to Remove the selected entry
        selected = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()

        # Do the remove
        entry = editBattles.pop(selected)
        # Store and Save
        WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = f"Command `{str(selected)}`: `{entry.replace(sep,sepSlash)}` removed."
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'move':
  # Cover Output that's always true
  examples = f"`{ExampleSimple} 0 2` to move command `0` to slot `2`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = EditAddError
  else: # We've got an existing battle, add to it.
    editBattles = RBattles[Pick]
    selected = newPos = None
    if not args or not args[0].isdigit() or not len(args) > 1 or int(args[0]) > len(editBattles)-1: # Check Args
      desc = "You must specify a numbered command to remove an entry in a plan."
      selectIntruction = ""
    else:
      # Make sure we've got enough arguments
      args = strArgs.split(' ')
      if(args[0].isdigit() and args[1].isdigit):
        # Ready to Remove the selected entry
        selected = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()
        newPos = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()
    if selected == None or newPos == None or selected < 0: # Not enough info provided
      desc = "You must specify a numbered command to move and a numbered new position to edit a plan."
      selectIntruction = ""
    else: # Success
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = MultiSourceError
        selectIntruction = SelectWorkingSource
      else: # Do the move
        entry = editBattles[selected]
        editBattles.pop(selected)
        # Check for newPos at end or more
        if newPos >= len(editBattles):
          editBattles.append(entry)
          newPos = len(editBattles)-1
        elif newPos < 0:
          editBattles.insert(0, entry)
          newPos = 0
        else:
          editBattles.insert(newPos, entry)
        # Store and Save
        WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = f'Command `{str(selected)}`: `"{entry.replace(sep,sepSlash)}"` => `{str(newPos)}`.'
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'map':
  # Cover Output that's always true
  examples = f"`{ExampleSimple} set`{newLine+ExampleSimple} set -mapsize 10x10 -options dc75`{newLine+ExampleSimple} clear`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = SelectPlanEdit

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to add map information to a plan."+newLine+newLine+"The `"+Mode+"` command is designed to simplify adding map information to an existing Battle Plan."+newLine+MapTextHelper
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, edit it.
    editBattles = RBattles[Pick]
    if not args:
      desc = "You must specify `set` or `clear` to modify a map."+newLine+newLine+"The `"+Mode+"` command is designed to simplify adding map information to an existing Battle Plan."+newLine+MapTextHelper
      selectIntruction = ""
    elif not Pick in WBattles: # Editing with Multi-Source
      # Output Build
      desc = "Cannot "+Mode+": `"+Pick+"`"+newLine+"_Mult-Source View is an advanced feature._"+newLine+"Battle Plans not in the working source [`"+OutputName+"`] cannot be edited."+newLine+"To change the working source: `!"+AliasCommand+" options source <NewSource>`"
      selectIntruction = SelectWorkingSource
      examples = ""
    else:
      if args[0] == 'set': # Add Map notes
        strArgs = strArgs.replace(args[0],'',1).lstrip()
        args.pop(0)
        rez=0
        # Find the prefix and entry
        for prefix in OptionsFixed['MapAttach']:
          editBattles[:] = (value for value in editBattles if not ((value.startswith('!i add ') or value.startswith('!init add ')) and value.endswith((prefix+' -p',prefix))))
          editBattles[:] = (value for value in editBattles if not (value.startswith('!i effect '+prefix+' map -attack') or value.startswith('!init effect '+prefix+' map -attack')))

        # Ready to Map the selected entry
        outCommand = ""
        result = ""
        mapCommands = []
        offset = 0
        # Parse the commands
        work = argparse(args)
        mapCommands += [f"""{argDescMap[x][0]}: {work.join(x,argDescMap[x][1])} ~""" for x in argDescMap.keys() if work.get(x)]
        mapCommands += [f"""{argSingleDescMap[x]}: {work.last(x)} ~""" for x in argSingleDescMap.keys() if work.last(x)]
        # Put all the commands together
        mapCommands = " ".join(mapCommands)
        mapCommands = mapCommands[::-1].replace('~ ', '', 1)[::-1]

        outCommand = f'!i add {AttachInit} {MapAttach} -p'
        result += f'`{outCommand}`'
        editBattles.insert(offset, outCommand)

        if mapCommands:
          mapCommands = f"""!i effect {MapAttach} map -attack "||{mapCommands}" """
          editBattles.insert(offset+1, mapCommands)
          result += f'{newLine}`{mapCommands.replace(sep, sepSlash)}`'

        # Store and Save
        WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        set_uvar(OutputName, dump_json(WBattles))

        # Output Build
        desc = ("Map Information Stored: "+newLine+result if result else 'No Map Information Provided to Store.')
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""

      elif args[0] == 'clear': # Remove the map notes
        strArgs = strArgs.replace(args[0],'',1).lstrip()
        args.pop(0)
        result = ""

        # Find the prefix and entry
        for prefix in OptionsFixed['MapAttach']:
          editBattles[:] = (value for value in editBattles if not ((value.startswith('!i add ') or value.startswith('!init add ')) and value.endswith((f'{prefix} -p',prefix)) or (value.startswith(f'!i effect {prefix} map -attack') or value.startswith(f'!init effect {prefix} map -attack'))))

        # Store and Save
        WBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        RBattles.update(load_json('{'+f'"{Pick}": {dump_json(editBattles)}'+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Map Information cleared"+(":"+newLine+result if result else '.')
        # Wipe because we succeded
        CodeAttempted = ""
        examples = ""
        selectIntruction = ""
      else:
        desc = "You must specify `set` or `clear` to modify a map."
        selectIntruction = ""

elif Mode == 'n' or Mode == 'p':
  CommandStore= load_json(get('BattlePlannerCache', '{}'))
  if not CommandStore:
    # Cover Output that's always true
    title = AliasName+" - More Display"
    desc = f"There is currently no cache to page through.{newLine}Run a command that has multiple pages first to use this interface"

    return f"""embed -title "{title}" -desc "{desc}{newLine+newLine+CodeAttempted if CodeAttempted else ''}" {Foot}"""

  else:
    if Mode == 'n':
      if CommandStore['CurrentPage'] < CommandStore['PageCount']:
        CommandStore['CurrentPage'] = CommandStore['CurrentPage'] + 1
    else:
      if CommandStore['CurrentPage'] > 1:
        CommandStore['CurrentPage'] = CommandStore['CurrentPage'] - 1
    set_uvar(CacheOutputName,dump_json(CommandStore))
    pagingInfo = f"**Page:** {str(CommandStore['CurrentPage'])}/{str(CommandStore['PageCount'])} `{AliasCommand} [n|p] Next|Previous Page`"

    for entry in load_json(CommandStore['Pages'][CommandStore['CurrentPage']-1]):
      commandList += entry.replace(sepSlash, sep)

    return f"""embed -title "{CommandStore['Title']}" -desc "{pagingInfo+newLine+newLine+commandList}{CommandStore['HelperText']}{CommandStore['BodyText']}" {Foot}"""

if Mode == 'view' or Display == 'view-pretty':
  # Used By View
  failed = False # Catches view specific issues
  work = entryOut = effectsOut = addsOut = notesOut = optsOut = metaOut = extraOut = finalName = ""

  # TODO: #2 Convert PlanList to an Inline
  if not Display == 'view-pretty': # Handle only our errors, not fall-throughs
    title = AliasName+" - Battle Viewer"
  if not TryPick: # No Plan Name Provided
    failed = True
    if not Display == 'view-pretty':
      desc="You must specify a Plan Name."
      selectIntruction = SelectPlanInstruct
      examples = f"`{ExampleSimple}`"
  elif not Pick: # No Plan Found
    failed = True
    if not Display == 'view-pretty':
      desc=f"Plan `{TryPick.title()}` Not Found"
      selectIntruction = SelectPlanInstruct
      examples = f"`{ExampleSimple}`"
  elif not Pick in RBattles: # No Entries
    failed = True
    if not Display == 'view-pretty':
      desc=f"Plan has no monsters or commands.{newLine}Add one with `{AliasCommand} add`"
      selectIntruction = ""

  if not failed: # No problems or not view mode, Go through the entries
    if not Display: # We're viewing
      CodeAttempted = ""
    hasName = ["add", "madd", "opt", "opts", "note", "effect"]
    AnyOut = False
    for entry in RBattles[Pick]:
      entryName = entryType = addMod = effectName = ''
      # Strip the init and type - init <Type> <Code>
      splitType = entry.split(' ')
      if len(splitType) > 1: # Handle the entry only having 1 arg
        entryType = splitType[1]
      else:
        entryType = splitType[0]
      # Some of the commands have no additional info
      code=entry.replace(f"""{AliasPrefix}init {entryType}""",'',1).replace(f"""{AliasPrefix}i {entryType}""",'',1).lstrip()

      # add| <modifier> <name> <args>
      # meta,metaset| <args> -- Ignore this one
      # madd| <name> <args>
      # opt,opts| <name> <args>
      # note| <name> <args>
      # effect| <target> <name> <args>
      # Pull out the Modifier for add
      if entryType == 'add':
        addMod = code.split(' ')[0]
        code = code.replace(f"""{addMod} """,'', 1)
      # Find the Entry Name
      if entryType in hasName:
        zeroSep = ''
        if code[0] == '\'' or code[0] == '\"':
          zeroSep = code[0]
        if zeroSep: # Go ahead and extract and strip either way
          entryName = code.split(zeroSep)[1].strip(r'\"\'')
        else:
          entryName = code.split(' ')[0]
        code = code.replace(f"""{zeroSep+entryName+zeroSep} """,'', 1)
      if entryType == 'effect': # Get the Effect Name too
        if code[0] == '\'' or code[0] == '\"':
          zeroSep = code[0]
        # If we are wrapped, go ahead and extract and strip
        if zeroSep:
          effectName = code.split(zeroSep)[1].strip(r'\"\'')
        else:
          effectName = code.split(' ')[0]
        code = code.replace(f"""{zeroSep+effectName+zeroSep} """,'', 1)
      # Argparse it
      work = argparse(code)
      # Handle multiple number (-n)|group|place at (-p)
      # Only append x# if -n more than 1
      entryName = f"""{entryName}{' (x'+work.last('n',None,str)+')' if work.get('n') and work.last('n',None,int) > 1 else ''}{' ['+work.last('group')+']' if work.get('group') else ''}{' {'+(work.last('p',None,str) if not addMod else str(addMod))+'}' if work.get('p') else ''}{(' DIS' if work.adv()==-1 else ' ADV' if work.adv()==1 else '')}"""

      # Extract all relevant args
      opts = [f"""-{x}: {work.last(x,None,str)}""" for x in argNamesSingle if work.get(x)]
      opts += [f"""-{x}""" for x in argNamesSpecial if work.get(x)]
      opts += [f"""-{x}: {work.join(x,', ')}""" for x in argNamesMulti if work.get(x)]
      opts += [f"""-{x}: {argDescMeta[x]}""" for x in argNamesMeta if work.get(x)]
      opts = " ".join(opts)
      # Handle special stuff
      if entryType == 'madd':
        if not entryOut:
          entryOut = f"""{newLine}**--Monsters--**"""
        # Store the results
        entryOut += f"""{newLine}• **{entryName}**{newLine + opts if opts else ''}"""
        AnyOut = True
      elif entryType == 'add':
        if not addsOut:
          addsOut = f"""{newLine}**--Placeholders--**"""
        # Store the results
        addsOut += f"""{newLine}• **{entryName}**{': ' + opts if opts else ''}"""
        AnyOut = True
      elif entryType == 'effect':
        # Add the Effects Header
        if not effectsOut:
          effectsOut = f"""{newLine}**--Effects--**"""
        # Store the results
        effectsOut += f"""{newLine}• **{entryName}** {': ' + opts if opts else ''}"""
        AnyOut = True
      elif entryType == 'opt' or entryType == 'opts':
        # Add the Notes Header
        if not optsOut:
          optsOut = f"""{newLine}**--Battlewide Opts--**"""
        # Store the results
        optsOut += f"""{newLine}• **{entryName}**{': ' + code if code else ''}"""
        AnyOut = True
      elif entryType == 'note':
        # Add the Notes Header
        if not notesOut:
          notesOut = f"""{newLine}**--Extra Notes--**"""
        # Store the results
        notesOut += f"""{newLine}• **{entryName}**: {code if code else ''}"""
        AnyOut = True
      elif entryType == 'meta' or entryType == 'metaset':
        # Add the Meta Header
        if not metaOut:
          metaOut = f"""{newLine}**--Battlewide Meta--**"""
        # Store the results
        metaOut += f"""{newLine+opts if opts else ''}"""
        AnyOut = True
        # If there's meta to change the name, display it up top too.
        if work.get('name'):
          finalName = f"""{Pick} - {work.last('name',None,str)}"""
      else: # thp, hp, move, goto, next, n, others
        if not extraOut:
          extraOut = f"""{newLine}**--Other Commands--**"""
        # Store the results
        extraOut += f"""{newLine}• {'**'+entryName+'**: ' if entryName else ''}**{entryType}** {code if code else ''}"""
        AnyOut = True
    if not AnyOut:
      entryOut = f"{newLine}Plan has no monsters or commands.{newLine}"+(f"Add one with `{AliasCommand} add`" if not Mode == 'delete' else '')
    body = f"""{newLine+newLine+"__"+Pick.title()+"__" if Pick else ''}{entryOut.replace('|',pipeSlash) if entryOut else ''}{newLine + addsOut.replace('|',pipeSlash) if addsOut else ''}{newLine + effectsOut.replace('|',pipeSlash) if effectsOut else ''}{newLine + optsOut.replace('|',pipeSlash) if optsOut else ''}{newLine + notesOut.replace('|',pipeSlash) if notesOut else ''}{newLine + metaOut.replace('|',pipeSlash) if metaOut else ''}{newLine + extraOut.replace('|',pipeSlash) if extraOut else ''}"""

  if Mode == 'view' and ViewOverride == 'view-numeric': # We want to view, but in numeric
    Mode = 'view-numeric'
  else:
    # Allows for others to use view code
    if finalName: # Handle Special View Names
      Pick = finalName
    # Build our Output
    desctemp = f"""{desc if desc else ''}{newLine+newLine+CodeAttempted if CodeAttempted else ''}{newLine if desc and not CodeAttempted else ''}{newLine+"Examples:"+newLine+examples if examples else ''}{newLine if examples else ''}{newLine+selectIntruction if selectIntruction else ''}{body if body else ''}""".replace(sepSlash, sep).replace(sepSingle,sepSingleSlash)
    #.replace(sep,sepSlash).replace(sepSingle,sepSingleSlash).replace(sepSingleSlash, sepSingle)

    if len(desctemp) <= 2048: # We're under limit - Do the display
      return f"""embed -title '{title}' -desc '{desctemp}' {"-f 'DisplayMode: "+Display+"'" if Display else ''} {Foot}"""
    else: # Over Limit - Paging Time
      Mode = 'view-numeric'

if Mode == 'view-numeric' or Display == 'view-numeric':
  failed = False # Catches view specific issues
  commandOut = ""
  if not Display == 'view-numeric': # Handle only our errors, not fall-throughs
    title = AliasName+" - Battle Viewer"
  if not TryPick: # No Plan Name Provided
    failed = True
    if not Display == 'view-numeric':
      desc="You must specify a Plan Name."
      selectIntruction = SelectPlanInstruct
  elif not Pick: # No Plan Found
    failed = True
    if not Display == 'view-numeric':
      desc="Plan `"+TryPick.title()+"` Not Found"
      selectIntruction = SelectPlanInstruct
  elif not RBattles[Pick]: # No Entries
    failed = True
    if not Display == 'view-numeric':
      desc=f"Plan has no monsters or commands.{newLine}Add one with `{AliasCommand} add`"
      selectIntruction = SelectPlanInstruct
  if not failed:
    if not Display: # We're viewing
      CodeAttempted = ""
      desc = ""
    # Paging stuff
    viewPlan = RBattles[Pick]
    commandList = newLine.join(['`'+str(i)+'`: '+x.replace(sep, sepSlash) for (i,x) in enumerate(viewPlan)])
    CommandSplit = commandList.splitlines(True)
    baseMessage = (f"""embed -title "{title}" -desc "{desc}
        Selected Battle Plan: `{Pick}`{newLine+'Attempted:'+newLine+'`'+FullCommand+'`' if CodeAttempted else ''}

        Commands:
        {newLine+newLine+"Examples:"+newLine+examples if examples else ''}{newLine+newLine+selectIntruction if selectIntruction else ''}" {Foot}""")
    baseMessageSize = len(baseMessage)

    if len("".join(CommandSplit))+baseMessageSize > 2048: # Needs to be split up
      workCommand = CommandSplit
      pagingInfoSize = 70
      CommandStore = load_json('{}')
      Pages = load_json('[]')
      splitAt = 20
      while workCommand:
        while(len("".join(workCommand[:splitAt]))+baseMessageSize+pagingInfoSize > 2048):
          splitAt = splitAt - 1
        Pages.append(dump_json(workCommand[:splitAt]))
        workCommand = workCommand[splitAt:splitAt+20]
        splitAt = 20
      # Now write out the cache, display the first page
      commandOut = "".join(load_json(Pages[0]))
      CommandStore['Title'] = title
      CommandStore['HelperText'] = (newLine+newLine+"Examples:"+newLine+examples if examples else '')+(newLine+newLine+selectIntruction if selectIntruction else '')
      CommandStore['BodyText'] = desc+newLine+"Selected Battle Plan: `"+Pick+"`"+(newLine+newLine+CodeAttempted if CodeAttempted else '')+newLine+newLine+"Commands:"+newLine
      CommandStore['PageCount'] = int(len(Pages))
      CommandStore['CurrentPage'] = 1

      CommandStore.update(load_json('{\"Pages\": '+dump_json(Pages)+'}'))
      set_uvar(CacheOutputName,dump_json(CommandStore))

      pagingInfo = f"**Page:** 1/{str(CommandStore.get('PageCount'))} `{AliasCommand} [n|p] Next|Previous Page`"
    else:
      commandOut = commandList
  return (f"""embed -title "{title}" -desc "{desc if desc else ''}{newLine+newLine+CodeAttempted if CodeAttempted else ''}{newLine+pagingInfo+newLine if pagingInfo else ''}{newLine if desc and not CodeAttempted else ''}{newLine+"Examples:"+newLine+examples if examples else ''}{newLine if examples else ''}{newLine+selectIntruction if selectIntruction else ''}{newLine+newLine+"__"+Pick.title()+"__"+newLine+"Commands:"+newLine+commandOut.replace('|',pipeSlash) if commandOut else ''}" {"-f 'DisplayMode: "+Display+"'" if Display else ''} {Foot}""")
</drac2>
-color <color> -thumb 'https://i.redd.it/6ot7a91iixr51.png'
