<drac2> # Battle Planner
args = &ARGS&
strArgs = """&*&"""

# Alias Generic Variables
AuthorName = 'Mahkasad#5996'
AliasName = 'Battle Planner'
Top_OptionsVarName = 'BattleToolOptions'
OptionsVarName = 'BattlePlanner'
LoadCheckName = 'BattleToolsLoadCheck'
AliasPrefix = ctx.prefix
AliasCommand = ctx.prefix+ctx.alias
versionNumner = "2.62"
version = "v"+versionNumner

#Alias Specific Variables
# I hate it, but double-escape it keeps it functional
newLine, sep, sepSingle, sepSlash, sepSingleSlash, openBrace, closeBrace, slash, pipeSlash ="\n",'\"','\'','\\\"', '\\\'', '{', '}', '\\', '\|'

Mode = Display = PlanList = WPlanList = Pick = TryPick = ''
Fuzzy = False
OptionsVar,RBattles, WBattles, RBattlePlans = load_json('{}'),load_json('{}'), load_json('{}'), load_json('[]')

# Options
OptionsDefault = {
  "SourceLocation": ["Battles"],
  "OutputLocation": "Battles",
  "MoreOutputLocation": "BattlesBeginMore",
  "PageCacheOutput": "BattlePlannerCache",
  "ViewOverride": "None",
  "MapAttach": "DM",
  "AttachInit": 20 }
# Handle options that take lists
OptionsLists = ["SourceLocation"]
# Handle options with specific choices
OptionsFixed = {
  "ViewOverride": ["none", "view-pretty", "view-numeric"],
  "MapAttach": ["DM", "Map", "Lair"] }
# The Descriptions of Each Option
# CodeName, ShortName, Valid Type, Description
OptionsDesc = {
  "SourceLocation": ["Source", "List of any UVAR|CVAR|SVAR*", "Where to load the Battle Plan List. Each source can be a list of GVARs"],
  "OutputLocation": ["Output", "Any Single UVAR|CVAR*", "Where to store the Battle Plan List."],
  "MoreOutputLocation": ["More", "Any Single UVAR*", "Where to store the begin commands cache."],
  "PageCacheOutput": ["Page", "Any Single UVAR*", "Where to store the page cache"],
  "ViewOverride": ["View", "Fixed Value", "The viewmode to force."],
  "MapAttach": ["Attach", "Fixed Value", "Map Attachment name to use."],
  "AttachInit": ["Init", "Any Integer", "The initiative count to place the Map Attach."] }

# Set Lists
Commands = ["view","begin", "end", "delete", "clear", "new", "rename", "add", "remove", "edit", "export", "move", "more", "p", "n", "options", "map"]
# Lists for specific fixed options
argNamesSingle = ["ac","controller","desc","dur","hp","max","name","note","parent","thp"]
argNamesSpecial = ["conc","end","h","rollhp"]
argNamesMulti = ["attack","b","d","immune","neutral","resist","sb","t","vuln"]
argNamesMeta = ["dyn", "turnnotif", "deathdelete"]
argDescMeta = {
  "dyn": "Dynamic initiative; Rerolls all initiatves at the start of a round",
  "turnnotif": "Notifies the controller of the next combatant in initiative",
  "deathdelete": "Toggles removing monsters below 0 HP" }
argDescMap = {
  "options": ("Options",""),
  "objects": ("Objects","/"),
  "walls": ("Walls","/"),
  "fow": ("FOW",","),
  "json": ("JSON",",") }

argSingleDescMap = {
  "bg": "Background",
  "mapsize": "Size",
  "view": "View" }

# Error Catching
set_uvar(LoadCheckName,int(get(LoadCheckName,-1))+1)

if args: # Fall Back Commands - In case someone screws up
  if args[0].lower() == 'fix':
    delete_uvar(LoadCheckName) # Success Loading
    return (f"""embed -title '{AliasName} - Fix' -desc "The {AliasName} Tool Load Check has been fixed.

    For a list of commands see `{AliasCommand} help`"  -footer '{AliasCommand} help | {version} Made by {AuthorName}'""")
  if args[0].lower() == 'reset':
    TopOptionsVar = load_json(get(Top_OptionsVarName, "{ \""+Top_OptionsVarName+"\": {}"+"}"))
    TopOptionsVar.update(load_json('{\"'+OptionsVarName+'\": {}'+'}'))
    set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))
    delete_uvar(LoadCheckName) # Success Loading
    return (f"""embed -title '{AliasName} - Reset' -desc "The {AliasName} Tool has done a reset of the `{OptionsVarName}` portion of the `{Top_OptionsVarName}` uvar. This should be done if the load uvars have been corrupted.

    If the problem persists try doing a `{AliasPrefix}uvar delete {Top_OptionsVarName}` or contact me on my Discord.
    For a list of commands see `{AliasCommand} help`"  -footer '{AliasCommand} help | {version} Made by {AuthorName}'""")
  elif args[0].lower() == 'clear':
    TopOptionsVar = load_json(get(Top_OptionsVarName, "{ \""+Top_OptionsVarName+"\": {}"+"}"))
    OptionsVar = TopOptionsVar.get(OptionsVarName, load_json('{\"'+OptionsVarName+'\": {}'+'}'))
    OutputName= OptionsVar.get('OutputLocation', OptionsDefault['OutputLocation'])
    if not len(args) > 1 or not args[1]=='confirm': # Make sure 'clear confirm'
      return (f"""embed -title '{AliasName} - Clear All Output Battles' -desc "You must specify a confirmation to clear all `{OutputName}` battles:
      `{AliasCommand} clear confirm`"  -footer '{AliasCommand} help | {version} Made by {AuthorName}'""")
    else: # Wipe out the uvar
      set_uvar(OutputName, "{}")
      delete_uvar(LoadCheckName) # Success Loading
      return (f"""embed -title '{AliasName} - Clear All Battles' -desc "All Battles in `{OutputName}` cleared. Add more with `{AliasCommand} new`"  -footer '{AliasCommand} help | {version} Made by {AuthorName}'""")

if int(get(LoadCheckName)) > 0: # If we get here and have already failed, then help message
  return (f"""embed -title '{AliasName} - Failed to Load' -desc "The {AliasName} Tool has failed to load more than once.
  This can happen because of a mangled battle plan or options var.
  
  If you are unsure what has happened try the following:
  
  **Check the Output File:**
    `{AliasPrefix}uvar {OptionsDefault['OutputLocation']}` - If you set a custom Output, change the name to that
    If the file looks incorrect it will need to be fixed.
  
  **If you are unsure how to fix the output file:**
    `{AliasCommand} clear confirm` - This will clear the Output file
  
  **If the problem persists:**
    `{AliasCommand} reset` - This will reset the Options file
  
  **Advanced Users:**
    Ensure that your input sources are correct.
    If you modify something manually be sure to do `{AliasCommand} fix`
    This will clear the failed load flag.

  If the problem still persists try doing a `{AliasPrefix}uvar delete {Top_OptionsVarName}`
  or contact me on my Discord (found in `{AliasCommand} help`).
  For a list of commands see `{AliasCommand} help`"  -footer '{AliasCommand} help | {version} Made by {AuthorName}'""")

# We've passed the first load in check
# Load the Options
TopOptionsVar = load_json(get(Top_OptionsVarName, "{ \""+OptionsVarName+"\": {}"+"}"))
OptionsVar.update(OptionsDefault)
OptionsVar.update(load_json(dump_json(TopOptionsVar.get(OptionsVarName, '{}'))))
# Load in the values by name
SourceName = OptionsVar.get('SourceLocation')
OutputName = OptionsVar.get('OutputLocation')
MoreOutputName= OptionsVar.get('MoreOutputLocation')
CacheOutputName = OptionsVar.get('PageCacheOutput')
ViewOverride = OptionsVar.get('ViewOverride')
MapAttach = OptionsVar.get('MapAttach')
AttachInit = OptionsVar.get('AttachInit')

# Load the values that are stored as a varname
MoreOutput= get(MoreOutputName)
CacheOutput = get(CacheOutputName)

# Handle issues with values
# This covers None failing to match
if ViewOverride and ViewOverride.lower() == 'none':
 ViewOverride = None

if not TopOptionsVar.get(OptionsVarName): # If they don't already have options, save them
  # Save to Top then save out Top
  TopOptionsVar.update(load_json('{'+sep+OptionsVarName+sep+': '+dump_json(OptionsVar)+'}'))
  set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))

# TODO: #1 Swap to loading names only to prevent Too Big error
for var in SourceName: # Load Sources
  # Single gvar
  if get_gvar(var):
    RBattles.update(load_json(get_gvar(var)))
  # Server Var
  if (currVar := get_svar(var)):
    jsonVar = load_json(currVar) or None
    if typeof(jsonVar) == 'SafeList': # Is gvar List
      for gvar in jsonVar:
        if get_gvar(gvar):
          RBattles.update(load_json(get_gvar(gvar)))
    elif get_gvar(jsonVar): # Single Gvar
      RBattles.update(load_json(get_gvar(jsonVar)))
    else: # Single Var
      RBattles.update(load_json(currVar))
   # User/Char Var
  if (currVar := get(var)):
    jsonVar = load_json(currVar) or None
    if typeof(jsonVar) == 'SafeList': # Is gvar List
      for gvar in jsonVar:
        if get_gvar(gvar):
          RBattles.update(load_json(get_gvar(gvar)))
    elif get_gvar(jsonVar): # Single Gvar
      RBattles.update(load_json(get_gvar(jsonVar)))
    else: # Single Var
      RBattles.update(load_json(currVar))
  # Failed to load it, pretend it's not there
# Load the Output
WBattles.update(load_json(get(OutputName,'{}')))

# Assign the Mode
if args:
  m = args.pop(0)
  strArgs = strArgs.replace(m,'',1).lstrip()
  # Do exact and then fuzzy match on commands
  Mode=[x for x in Commands if m.lower() == x]
  if not Mode:
    Mode=[x for x in Commands if m.lower() in x]
  if Mode:
    Mode = Mode[0]

# Embed Ready
desc = commandList = examples = selectIntruction = pagingInfo = ""
fullCommand = f"""{AliasCommand}{' '+" ".join(&ARGS&) if &ARGS& else ''}"""
title = AliasName+(" - "+Mode.capitalize() if Mode else '')
attempted = "Attempted:"+newLine+"`"+fullCommand+"`"
foot = f""" -footer '{AliasCommand} help | Source: [{SourceName[0] if len(SourceName)==1 else ",".join(SourceName)}]{' | Output:['+OutputName+']' if not OutputName == ",".join(SourceName) else ''} | {version} Made by {AuthorName}'"""
# Fixed Strings
MultiSourceError = newLine+"_Mult-Source View is an advanced feature._"+newLine+newLine+"Battles cannot be edited unless stored in Output: `"+OutputName+"`"+newLine+"To change the Output: `"+AliasCommand+" options`"
MapTextHelper = "Using `set` alone primes the battle for the `"+AliasPrefix+"map` command. Using `set` along with the following will assign map information:"+newLine+"`[-bg <url link>]` `*`"+newLine+"`[-mapsize <XxY size>]` `*^`"+newLine+"`[-view <view>]` `*`"+newLine+"`[-options <options>]`"+newLine+"`[-objects <objects>]`"+newLine+"`[-walls <walls>]`"+newLine+"`[-fow <fow>]`"+newLine+"`[-json <json>]`"+newLine+newLine+"**Note:**"+newLine+"**`^` Indicates this value is required!**"+newLine+"**`*` Indicates only the last value will be used.**"
PlanEditExample = " \\\"Example Battle\\\" "+AliasPrefix+"i madd Ogre -n 2`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" "+AliasPrefix+"i madd \\\"Ancient Black Dragon\\\"`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" "+AliasPrefix+"i effect OG1 bulk -ac +10`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" "+AliasPrefix+"i meta -name \\\"Boss Battle 2\\\"`"
EditNewError = "Battle `"+TryPick.capitalize()+"` not found."+newLine+"Did you mean `new`?"

if not (Mode=='p' or Mode=='n'): # Delete the Cache
  delete_uvar(CacheOutputName)

if args: # Pull out what is being tried
  TryPick = args.pop(0)
  for begins in [TryPick, sep+TryPick+sep, sepSingle+TryPick+sepSingle]:
    if strArgs.startswith(begins):
      strArgs = strArgs.replace(begins,'',1).lstrip()
      break
  TryPick = TryPick.lower()
if RBattles: # Sort the Battles so we can get correct hits
  # I hate this. We also fuzzy match in reverse
  # This fixes the 'Arctic T1 82' 'Arctic T1 8' issue
  RBattlePlans = list(RBattles)
  RBattlePlans.sort()
  for plan in RBattlePlans:
    # Build the plan list
    PlanList += "`"+sepSingle+plan.capitalize()+sepSingle+"`"+newLine
    # if we're doing something
    # exact match check
    if TryPick and TryPick == plan.lower():
      Pick = plan
  # if we're doing something
  # fuzzy match check
  # search backwards to handle 'B 8' 'B 82' issue
  if not Pick:
    for plan in RBattlePlans[::-1]:
      if TryPick and TryPick in plan.lower():
        Pick = plan
        Fuzzy = True
if WBattles: # Generate Working Battle List
  WBattlePlans = list(WBattles)
  WBattlePlans.sort()
  for plan in WBattlePlans:
    # Build the plan list
    WPlanList += "`"+sepSingle+plan.capitalize()+sepSingle+"`"+newLine

# If we got to here, then they've loaded.
delete_uvar(LoadCheckName) # Success Loading - Clear the error checker

if not Mode and PlanList: # Check for no inputs
  desc = "The Battle Planner Tool is designed for interacting with Avrae's Combat Initiative and simplify preparing combats."+newLine+newLine+"For a list of commands see `"+AliasCommand+" help`"+newLine+"To view a battle plan use: `"+AliasCommand+" view <battlename>`"
  selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  Display = ViewOverride if ViewOverride else 'view-pretty'

if not PlanList and not (Mode == 'new' or Mode == 'options'): # No battles
  title = AliasName
  desc = "No Battles Found. Add one with `"+AliasCommand+" new`, `"+AliasPrefix+"denc`, or manually to: `"+AliasPrefix+"uvar "+",".join(SourceName)+"`."+newLine+newLine+"For a list of commands see `"+AliasCommand+" help`"
  
  Display = ViewOverride if ViewOverride else 'view-pretty'

elif Mode == 'options':
  # We clear this if we succeed
  examples = "Examples:"+newLine+"`"+AliasCommand+" "+Mode+" View pretty` - Set an option"+newLine+"`"+AliasCommand+" "+Mode+" Source Battles Battles2` - Set an option that uses a list"+newLine+"`"+AliasCommand+" Source default` - For restoring a default option"+newLine+"`"+AliasCommand+" reset` - For restoring all defaults"
  newOption = ""
  if not TryPick: # Just print them out
    desc="Loaded options for the "+AliasName+"."+newLine+"To Change an option select the name and new command."+newLine+"See examples for more."
    attempted = ""
  else: # We're trying to make a change
    opt = [x for x in OptionsVar.keys() if TryPick.lower() == x.lower()]
    if not opt: # Failed Exact, try Fuzzy 
      opt = [x for x in OptionsVar.keys() if TryPick.lower() in x.lower()]
    if opt and args: # Don't change unless we've got something to change to
      opt = opt[0]
      if strArgs == 'default': # Check if we want to Default
        newOption = OptionsDefault[opt]
      elif opt in OptionsFixed.keys(): # Check if we're a fixed option
        optionTry = args.pop(0)
        strArgs.replace(str(optionTry),'',1).lstrip()
        fixedOption = [x for x in OptionsFixed[opt] if optionTry.lower() in x.lower()]
        if fixedOption: # Found it, assign
          newOption = fixedOption[0]
      elif opt in OptionsLists: # Check if we're an option that wants lists
        newOption = args
      else: # Just a normal option
        newOption = strArgs
      if newOption: # Fail Check - If we exist we are assigning now
        OptionsVar[opt] = newOption
        desc = "Option: `"+opt+"` assigned to: `"+newOption+"`"
        examples = attempted = "" # Wipe These on success
        #Save to Top then save Top
        TopOptionsVar.update(load_json('{'+sep+OptionsVarName+sep+': '+dump_json(OptionsVar)+'}'))
        set_uvar(Top_OptionsVarName, dump_json(TopOptionsVar))

    if not newOption: # Didn't find an option
      desc="Failed to find that option or provide a new setting."+newLine+"To Change an option select the name and new command."
  # Show the current option values
  optionsBody = f"""{newLine.join(["**"+x+"**: `"+OptionsVar[x]+"`"+(" | Default: `"+OptionsDefault[x]+"`" if not OptionsVar[x] == OptionsDefault[x] else '') for x in OptionsVar.keys()])} """
  # Build the option descriptions if nothing was changed
  optionsText = ""
  
  if not newOption: # Only show the full info if we've not changed anything
    optionsText = "**Option Info:**"+newLine+newLine.join(["`"+OptionsDesc[x][0]+"`: "+OptionsDesc[x][1]+newLine+"-"+OptionsDesc[x][2]+(newLine+"--_Valid Options_ - `"+"` | `".join(y for y in OptionsFixed[x])+"`" if x in OptionsFixed else '')+newLine for x in OptionsDesc])+newLine+"_Options with a * are Case Sensitive_"
  else: # Show the Info for the option that was changed
    optionsText = "**Option Info:**"+newLine+"`"+OptionsDesc[opt][0]+"`: "+OptionsDesc[opt][1]+newLine+"-"+OptionsDesc[opt][2]+(newLine+"--_Valid Options_ - `"+"` | `".join(y for y in OptionsFixed[opt])+"`" if opt in OptionsFixed else '')+newLine+newLine+"_Options with a * are Case Sensitive_"

  return f"""embed -title "{title}" -desc "{desc}{newLine+attempted if attempted else ''}{newLine+newLine+optionsBody}{newLine+newLine+optionsText if optionsText else ''}{newLine+newLine+examples if examples else ''}" {foot}"""

elif Mode == 'end':
  # End is simple, just call it
  return (f"""i end""")
  
elif Mode == 'begin':
  # Used by All
  examples = "`"+AliasCommand+" "+Mode+" "+sepSlash+"Example Battle"+sepSlash+" <args>`"
  
  selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # No Plan Name Provided
    desc = "You must specify a Plan Name."
  elif not Pick:  # No Plan Found
    desc = "Battle `"+TryPick.capitalize()+"` Not Found"
  elif not RBattles[Pick]: # No Entries
    desc = "Battle `"+Pick+"` has no monsters or commands."
  else: # No errors, prepare commands
    # Handle passing additional args to i begin
    bargs = " ".join(args)
    # Prepare the complete set of commands
    multiCommand = f"""multiline{newLine}"""
    command = f"""{AliasPrefix}i begin {bargs}"""
    count,total,moreCount = 2,0,1 # Two less so we can store the more embed
    limit = 20
    moreSet = load_json('[]')
    MoreBattles = load_json('{}')
    output=""
    for entry in RBattles[Pick]:
      count,total = count + 1, total + 1
      if moreSet or MoreBattles or count > limit:
        if not moreSet: # FirstTime for this more, hit on count
          if len(RBattles[Pick])-total == 0: # We fit in if no more embed
            command += newLine + entry.replace(entry[0],AliasPrefix)
          else: # Otherwise, start the more
            count = 2
            moreSet.append(entry)
        elif count > limit: #Over limit
          if len(RBattles[Pick])-total == 0:
            moreSet.append(entry)
          else:
            MoreBattles.update(load_json('{\"'+plan+str(moreCount)+'\": '+dump_json(moreSet)+'}'))
            moreSet, count = load_json('[]'), 1
            moreCount += 1
            moreSet.append(entry)
        else: # Regular, store
          moreSet.append(entry)
      else: # Still in size
        command += newLine + entry.replace(entry[0],AliasPrefix)
    if MoreBattles or moreSet: # Store the More Commands if needed
      if moreSet: # Final entry store
        MoreBattles.update(load_json('{\"'+plan+str(moreCount)+'\": '+dump_json(moreSet)+'}'))
      MoreBattles["timer"] = int(time()) + 20
      MoreBattles["commandCount"] = total - 19

      set_uvar(MoreOutputName,dump_json(MoreBattles))
      # Append the More Dialog
      moreEmbed = (f"""{AliasPrefix}embed -title "{AliasName} - More Battles" -desc "More Battles has been used due to there being more than `20` commands. (This includes `{AliasPrefix}i begin` and this message). When the current batch of commands finishes, call `{AliasCommand} more` to continue adding to initiative. There are `{MoreBattles["commandCount"]}` more commands in `{len(MoreBattles)-2}` batches." {foot}""")
      multiCommand += moreEmbed + newLine
    # Call the Begin
    return multiCommand + command # moreEmbed[1:] #

elif Mode == 'more':
  # Read the More
  MoreBattles = load_json(get(MoreOutputName, '{}'))
  if not MoreBattles: # Handle Empty
    return (f"""embed -title "{AliasName} - More Battle" -desc "There is not currently more battle plan to add to Initiative. Did you mean `{AliasCommand} begin`?
          Attempted:{newLine}`{fullCommand}`" {foot}""")
  if int(MoreBattles.timer) > int(time()): #Still on Cooldown
    return (f"""embed -title "{AliasName} - More Battle" -desc "The `multiline` command is on cooldown for: `{int(MoreBattles.timer) - int(time())}` seconds. Please wait before calling {Mode} again.
    
    There are `{MoreBattles.commandCount}` more commands in `{len(MoreBattles)-2}` batches." {foot}""")
  
  # Take out the admin stuff
  MoreBattles.pop("timer")
  prior = MoreBattles.pop("commandCount")
  # Get the keys in a list
  entries = list(MoreBattles.keys())[0]
  command = f"""multiline{newLine}"""
  current = MoreBattles.pop(entries)
  command += newLine.join(current)
  # Call the commands
  if MoreBattles: # More more remains
    moreEmbed = (f"""{newLine}{AliasPrefix}embed -title "{AliasName} - More Battles" -desc "Commands Remain: `{newLine.join(MoreBattles.keys())}`" {foot}""")
    MoreBattles["timer"] = time() + 20
    MoreBattles["commandCount"] = prior - len(current)
    command += moreEmbed
    set_uvar(MoreOutputName,dump_json(MoreBattles))
  else:
    set_uvar(MoreOutputName,'{}')
  return command # moreEmbed[1:] #

elif Mode == 'new':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples = "`"+AliasCommand+" "+Mode+PlanEditExample
  selectIntruction = "Existing Battle Plans:"+newLine+PlanList
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to make a new plan."
  elif Pick and not Fuzzy: # Plan already exists and is exact
    desc = "Battle `"+TryPick.capitalize()+"` already exists."+newLine+"Did you mean `add`, `remove`, `move`, `rename`, or `edit`?"
  else: # We've got a new battle, name it.
    BName = TryPick.strip(sepSingle+sepSlash+sep)
    # Do the replace
    editBattles = load_json('[]')
    # Split the lines to get all our commands!
    commandList = strArgs.splitlines()
    # Iterate over the lines
    for line in commandList:
      line = line.strip()
      # Handle the value starting with a quote we missed
      if line[0] == sep:
        line = line.replace(sep,'',1)
        line = line[::-1].replace(sep,'',1)[::-1]
      editBattles.append(line)
    # Store and Save
    WBattles.update(load_json('{\"'+BName+'\": '+dump_json(editBattles)+'}'))
    RBattles.update(load_json('{\"'+BName+'\": '+dump_json(editBattles)+'}'))
    # Save out
    set_uvar(OutputName, dump_json(WBattles))
    Pick = BName
    # Output Build
    if not args:
      desc = "Battle __"+Pick.title()+"__ Created without monsters. Use `add` to add in monsters."
    else:
      desc = "Battle __"+Pick.title()+"__ Created with entry: `"+strArgs.replace(sep,sepSlash)+"`"
    # Wipe because we succeded
    attempted = ""
    examples = ""
    selectIntruction = ""

elif Mode == 'delete':
  # Output things used by all
  examples = "`"+AliasCommand+" "+Mode+" "+sepSlash+"Example Battle"+sepSlash+"`"
  
  selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  Display = ViewOverride if ViewOverride else 'view-pretty'

  if not TryPick: # Put nothing -- TUTORIAL HERE
    desc = "You must specify a Plan Name to Delete."
  elif not Pick: # Not Found
    desc = "Battle `"+TryPick.capitalize()+"` Not Found"
  else:
    if not Pick in WBattles: # Not in the working set
        # Output Build
        desc = "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
        examples = ""
    else: # Success
      PlanList = PlanList.replace(f"""`\'{Pick.title()}\'`{newLine}""",'',1)
      WBattles.pop(Pick)
      # RBattles.pop(Pick) # We don't do this so we can display what was deleted
      set_uvar(OutputName, dump_json(WBattles))
      desc = "Battle Deleted: `"+Pick.title()+"`"
      # Clear these because success
      examples = ""
      attempted = ""
      selectIntruction = ""

elif Mode == 'rename':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples ="`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" Battle 2`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" Super Cool Battle`"
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to rename a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, rename it.
    if not args: # You must have more to get here. No adding empty
      desc = "You must specify a new name to rename a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc =  "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
        examples = ""
      else:
        # Ready to Store the Modified Battle
        strArgs = strArgs.strip(sepSingle+sepSlash+sep)
        editBattles = WBattles[Pick]
        WBattles.pop(Pick)
        RBattles.pop(Pick)
        WBattles.update(load_json('{\"'+strArgs+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+strArgs+'\": '+dump_json(editBattles)+'}'))
        # Save out
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Renamed Battle from:"+newLine+"`"+Pick.title()+"` => `"+strArgs.capitalize()+"`"
        Pick = strArgs
        # Wipe because we succeded
        attempted = ""
        examples = ""
        selectIntruction = ""

elif Mode == 'add':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples = "`"+AliasCommand+" "+Mode+PlanEditExample
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, add to it.
    if not args: # You must have more to get here. No adding empty
      desc = "You must specify a command to add to a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc =  "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
        examples = ""
      else: # Ready to Store the Modified Battle
        editBattles = WBattles[Pick]
        # Split the lines to get all our commands!
        commandList = strArgs.splitlines()
        # Iterate over the lines
        for line in commandList:
          line = line.strip()
          # Handle the value starting with a quote we missed
          if line[0] == sep:
            line = line.replace(sep,'',1)
            line = line[::-1].replace(sep,'',1)[::-1]
          editBattles.append(line)
        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        # Save out
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "__"+Pick.title()+"__: Added entry `"+strArgs.replace(sep,sepSlash)+"`"
        # Wipe because we succeded
        attempted = ""
        examples = "" 
        selectIntruction = ""

elif Mode == 'export':
  # Cover Output that's always true
  title = AliasName+" - Plan "+Mode.capitalize()
  
  examples = "`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\"`"
  Display = ViewOverride if ViewOverride else 'view-pretty'
  selectIntruction = "Select a Battle Plan to Export:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to export a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing plan, Output it
    exportBattle = RBattles[Pick]
    command = f"""```{newLine+AliasCommand} new {Pick}"""
    # Iterate over the commands
    for comm in exportBattle:
      command += newLine + comm.replace(comm[0],AliasPrefix)

    # Output the Plan    
    if args and 'mobile' in args:
      # Mobile-Friendly Mode
      title += " - Mobile Mode"
    else:
      desc = "Exporting Plan `"+Pick+"`. Add `mobile` for an easier phone copy."+newLine+"To duplicate the plan copy paste the following block:"+newLine
    desc += command+newLine+"```"   
    return (f"""embed -title '{title}' -desc '{desc}' {foot}""")

elif Mode == 'edit':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples = "`"+AliasCommand+" "+Mode+PlanEditExample
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = "Battle `"+TryPick.capitalize()+"` is empty."+newLine+"Did you mean `add`?"
  else: # We've got an existing battle, edit it.
    editBattles = RBattles[Pick]
    if not len(args) > 1 or not args[0].isdigit() or int(args[0]) > len(editBattles)-1: # You must have more to get here. No adding empty
      desc = "You must specify a numbered command to edit and a new command to edit a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
        examples = ""
      else:
        # Ready to Modify the selected entry
        selected = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()
        if selected == None or selected < 0: # Not enough info provided
          desc = "You must specify a numbered command to move and a numbered new position to edit a plan."
          selectIntruction = ""
        # Do the replace
        entry = editBattles[selected]
        strArgs = strArgs.strip()
        if strArgs[0] == sep:
          strArgs = strArgs.replace(sep,'',1)
          strArgs = strArgs[::-1].replace(sep,'',1)[::-1]
        editBattles[selected] = strArgs
        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Command `"+str(selected)+"`:`"+entry.replace(sep,sepSlash)+"` modified to `"+strArgs.replace(sep,sepSlash)+"`."
        # Wipe because we succeded
        attempted = ""
        examples = "" 
        selectIntruction = ""

elif Mode == 'remove':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples = "`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" 1` to remove command `1`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = "Battle `"+TryPick.capitalize()+"` is empty."+newLine+"Did you mean `add`?"
  else: # We've got an existing battle, modify it.
    editBattles = RBattles[Pick]
    if not args or not args[0].isdigit() or int(args[0]) > len(editBattles)-1: # Check Args
      desc = "You must specify a numbered command to remove an entry in a plan."
      selectIntruction = ""
    else:
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
        examples = ""
      else: # Ready to Remove the selected entry
        selected = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()

        # Do the remove
        entry = editBattles.pop(selected)
        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Command `"+str(selected)+"`:`"+entry.replace(sep,sepSlash)+"` removed."
        # Wipe because we succeded
        attempted = ""
        examples = "" 
        selectIntruction = ""

elif Mode == 'move':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  
  examples = "`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" 0 2` to move command `0` to slot `2`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to edit a plan."
  elif not Pick: # No Plan Found
    desc = EditNewError
  elif not RBattles[Pick]: # Empty Battle
    desc = "Battle `"+TryPick.capitalize()+"` is empty."+newLine+"Did you mean `add`?"
  else: # We've got an existing battle, add to it.
    editBattles = RBattles[Pick]
    selected = newPos = None
    if not args or not args[0].isdigit() or not len(args) > 1 or int(args[0]) > len(editBattles)-1: # Check Args
      desc = "You must specify a numbered command to remove an entry in a plan."
      selectIntruction = ""
    else:
      # Make sure we've got enough arguments
      args = strArgs.split(' ')
      if(args[0].isdigit() and args[1].isdigit):
        # Ready to Remove the selected entry
        selected = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()
        newPos = int(args.pop(0))
        strArgs = strArgs.replace(str(selected),'',1).lstrip()
    if selected == None or newPos == None or selected < 0: # Not enough info provided
      desc = "You must specify a numbered command to move and a numbered new position to edit a plan."
      selectIntruction = ""
    else: # Success
      if not Pick in WBattles: # Editing with Multi-Source
        # Output Build
        desc = "Cannot "+Mode+" to `"+Pick+"`: "+MultiSourceError
        selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
      else: # Do the move
        entry = editBattles[selected]
        editBattles.pop(selected)
        # Check for newPos at end or more
        if newPos >= len(editBattles):
          editBattles.append(entry)
          newPos = len(editBattles)-1
        elif newPos < 0:
          editBattles.insert(0, entry)
          newPos = 0
        else:
          editBattles.insert(newPos, entry)
        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Command `"+str(selected)+"`:`"+sepSlash+entry.replace(sep,sepSlash)+sepSlash+"` moved to `"+str(newPos)+"`."
        # Wipe because we succeded
        attempted = ""
        examples = "" 
        selectIntruction = ""

elif Mode == 'map':
  # Cover Output that's always true
  title = AliasName+" - Battle Editor ("+Mode.capitalize()+")"
  examples = "`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" set`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" set [-bg] [-mapsize] [-options] [-objects] [-walls] [-view]`"+newLine+"`"+AliasCommand+" "+Mode+" \\\"Example Battle\\\" clear`"
  Display = ViewOverride if ViewOverride else 'view-numeric'
  selectIntruction = "Select a Battle Plan to edit:"+newLine+PlanList

  if not TryPick: # No Plan Name Provided -- TUTORIAL HERE
    desc = "You must specify a Plan Name to add map information to a plan."+newLine+newLine+"The `"+Mode+"` command is designed to simplify adding map information to an existing Battle Plan."+newLine+MapTextHelper
  elif not Pick: # No Plan Found
    desc = EditNewError
  else: # We've got an existing battle, edit it.
    editBattles = RBattles[Pick]
    if not args:
      desc = "You must specify `set` or `clear` to modify a map."+newLine+newLine+"The `"+Mode+"` command is designed to simplify adding map information to an existing Battle Plan."+newLine+MapTextHelper
      selectIntruction = ""
    elif not Pick in WBattles: # Editing with Multi-Source
      # Output Build
      desc = "Cannot "+Mode+": `"+Pick+"`"+newLine+"_Mult-Source View is an advanced feature._"+newLine+"Battles not in the working source [`"+OutputName+"`] cannot be edited."+newLine+"To change the working source: `!"+AliasCommand+" options source <NewSource>`"
      selectIntruction = "Working Source Battles:"+newLine+(WPlanList if WPlanList else '`None Stored`') # Special Instruction
      examples = ""
    else:
      if args[0] == 'set': # Add Map notes
        strArgs = strArgs.replace(args[0],'',1).lstrip()
        args.pop(0)
        rez=0
        # Find the prefix and entry
        for prefix in OptionsFixed['MapAttach']:
          editBattles[:] = (value for value in editBattles if not ((value.startswith('!i add ') or value.startswith('!init add ')) and value.endswith((prefix+' -p',prefix))))
          editBattles[:] = (value for value in editBattles if not (value.startswith('!i effect '+prefix+' map -attack') or value.startswith('!init effect '+prefix+' map -attack')))

        # Ready to Map the selected entry
        outCommand = ""
        result = ""
        mapCommands = []
        offset = 0
        # Parse the commands
        work = argparse(args)
        mapCommands += [f"""{argDescMap[x][0]}: {work.join(x,argDescMap[x][1])} ~""" for x in argDescMap.keys() if work.get(x)]
        mapCommands += [f"""{argSingleDescMap[x]}: {work.last(x)} ~""" for x in argSingleDescMap.keys() if work.last(x)]
        # Put all the commands together
        mapCommands = " ".join(mapCommands)
        mapCommands = mapCommands[::-1].replace('~ ', '', 1)[::-1]

        outCommand = f'!i add {AttachInit} {MapAttach} -p'
        result += '`'+outCommand+'`'+newLine
        editBattles.insert(offset, outCommand)

        if mapCommands:
          mapCommands = "!i effect "+MapAttach+" map -attack \"||" + mapCommands+"\""
          editBattles.insert(offset+1, mapCommands)
          result += '`'+mapCommands.replace(sep, sepSlash)+'`'

        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        set_uvar(OutputName, dump_json(WBattles))

        # Output Build
        desc = ("Map Information Stored: "+newLine+result if result else 'No Map Information Provided to Store.')
        # Wipe because we succeded
        attempted = ""
        examples = ""
        selectIntruction = ""

      elif args[0] == 'clear': # Remove the map notes
        strArgs = strArgs.replace(args[0],'',1).lstrip()
        args.pop(0)
        result = ""

        # Find the prefix and entry
        for prefix in OptionsFixed['MapAttach']:
          editBattles[:] = (value for value in editBattles if not ((value.startswith('!i add ') or value.startswith('!init add ')) and value.endswith((prefix+' -p',prefix)) or (value.startswith('!i effect '+prefix+' map -attack') or value.startswith('!init effect '+prefix+' map -attack'))))

        # Store and Save
        WBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        RBattles.update(load_json('{\"'+Pick+'\": '+dump_json(editBattles)+'}'))
        set_uvar(OutputName, dump_json(WBattles))
        # Output Build
        desc = "Map Information cleared"+(":"+newLine+result if result else '.')
        # Wipe because we succeded
        attempted = ""
        examples = "" 
        selectIntruction = ""
      else:
        desc = "You must specify `set` or `clear` to modify a map."
        selectIntruction = ""

elif Mode == 'n' or Mode == 'p':
  CommandStore= load_json(get('BattlePlannerCache', '{}'))
  if not CommandStore:
    # Cover Output that's always true
    title = AliasName+" - More Display"
    desc = "There is currently no cache to page through."+newLine+"Run a command that has multiple pages first to use this interface"

    return f"""embed -title "{title}" -desc "{desc}{newLine+newLine+attempted if attempted else ''}"  {foot}"""

  else:
    if Mode == 'n':
      if CommandStore['CurrentPage'] < CommandStore['PageCount']:
        CommandStore['CurrentPage'] = CommandStore['CurrentPage'] + 1
    else:
      if CommandStore['CurrentPage'] > 1:
        CommandStore['CurrentPage'] = CommandStore['CurrentPage'] - 1
    
    set_uvar(CacheOutputName,dump_json(CommandStore))
    
    pagingInfo = "**Page:** "+str(CommandStore['CurrentPage'])+"/"+str(CommandStore['PageCount'])+" `"+AliasCommand+" [n|p] Next|Previous Page`"

    for entry in load_json(CommandStore['Pages'][CommandStore['CurrentPage']-1]):
      commandList += entry.replace(sepSlash, sep)

    return f"""embed -title "{CommandStore['Title']}" -desc "{pagingInfo+newLine+newLine+commandList}{CommandStore['HelperText']}{CommandStore['BodyText']}"  {foot}"""

if Mode == 'view' or Display == 'view-pretty':
  # Used By View
  failed = False # Catches view specific issues
  work = entryOut = effectsOut = addsOut = notesOut = optsOut = metaOut = extraOut = finalName = ""
  # TODO: #2 Convert PlanList to an Inline
  if not Display == 'view-pretty': # Handle only our errors, not fall-throughs
    title = AliasName+" - Battle Viewer"
  if not TryPick: # No Plan Name Provided
    failed = True
    if not Display == 'view-pretty':
      desc="You must specify a Plan Name."
      selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  elif not Pick: # No Plan Found
    failed = True
    if not Display == 'view-pretty':
      desc="Battle `"+TryPick.capitalize()+"` Not Found"
      selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  elif not Pick in RBattles: # No Entries
    failed = True
    if not Display == 'view-pretty':
      desc="Battle has no monsters or commands."+newLine+"Add one with `"+AliasCommand+" add`"
      selectIntruction = ""

  if not failed: # No problems or not view mode, Go through the entries
    if not Display: # We're viewing
      attempted = ""
    hasName = ["add", "madd", "opt", "opts", "note", "effect"]
    for entry in RBattles[Pick]:
      entryName = entryType = addMod = effectName = ''
      # Strip the init and type - init <Type> <Code>
      splitType = entry.split(' ')
      if len(splitType) > 1: # Handle the entry only having 1 arg
        entryType = splitType[1]
      else:
        entryType = splitType[0]
      # Some of the commands have no additional info
      code=entry.replace(f"""{AliasPrefix}init {entryType}""",'',1).replace(f"""{AliasPrefix}i {entryType}""",'',1).lstrip()

      # add| <modifier> <name> <args>
      # meta,metaset| <args> -- Ignore this one
      # madd| <name> <args>
      # opt,opts| <name> <args>
      # note| <name> <args>
      # effect| <target> <name> <args>
      # Pull out the Modifier for add
      if entryType == 'add':
        addMod = code.split(' ')[0]
        code = code.replace(f"""{addMod} """,'', 1)
      # Find the Entry Name
      if entryType in hasName:
        zeroSep = ''
        if code[0] == sepSingle or code[0] == sep:
          zeroSep = code[0]
        if zeroSep: # Go ahead and extract and strip either way
          entryName = code.split(zeroSep)[1].strip(r'\"\'')
        else:
          entryName = code.split(' ')[0]
        code = code.replace(f"""{zeroSep+entryName+zeroSep} """,'', 1)
      if entryType == 'effect': # Get the Effect Name too
        if code[0] == sepSingle or code[0] == sep:
          zeroSep = code[0]
        # If we are wrapped, go ahead and extract and strip
        if zeroSep:
          effectName = code.split(zeroSep)[1].strip(r'\"\'')
        else:
          effectName = code.split(' ')[0]
        code = code.replace(f"""{zeroSep+effectName+zeroSep} """,'', 1)
      # Argparse it
      work = argparse(code)
      # Handle multiple number (-n)|group|place at (-p)
      # Only append x# if -n more than 1
      entryName = f"""{entryName}{' (x'+work.last('n',None,str)+')' if work.get('n') and work.last('n',None,int) > 1 else ''}{' ['+work.last('group')+']' if work.get('group') else ''}{' {'+(work.last('p',None,str) if not addMod else str(addMod))+'}' if work.get('p') else ''}{(' DIS' if work.adv()==-1 else ' ADV' if work.adv()==1 else '')}"""

      # Extract all relevant args
      opts = [f"""-{x}: {work.last(x,None,str)}""" for x in argNamesSingle if work.get(x)]
      opts += [f"""-{x}""" for x in argNamesSpecial if work.get(x)]
      opts += [f"""-{x}: {work.join(x,', ')}""" for x in argNamesMulti if work.get(x)]
      opts += [f"""-{x}: {argDescMeta[x]}""" for x in argNamesMeta if work.get(x)]
      opts = " ".join(opts)
      # Handle special stuff
      if entryType == 'madd':
        if not entryOut:
          entryOut = f"""{newLine}**--Monsters--**"""
        # Store the results
        entryOut += f"""{newLine}• **{entryName}**{newLine + opts if opts else ''}"""
      elif entryType == 'add':
        if not addsOut:
          addsOut = f"""{newLine}**--Placeholders--**"""
        # Store the results
        addsOut += f"""{newLine}• **{entryName}**{': ' + opts if opts else ''}"""
      elif entryType == 'effect':
        # Add the Effects Header
        if not effectsOut:
          effectsOut = f"""{newLine}**--Effects--**"""
        # Store the results
        effectsOut += f"""{newLine}• **{entryName}** {': ' + opts if opts else ''}"""
      elif entryType == 'opt' or entryType == 'opts':
        # Add the Notes Header
        if not optsOut:
          optsOut = f"""{newLine}**--Battlewide Opts--**"""
        # Store the results
        optsOut += f"""{newLine}• **{entryName}**{': ' + code if code else ''}"""
      elif entryType == 'note':
        # Add the Notes Header
        if not notesOut:
          notesOut = f"""{newLine}**--Extra Notes--**"""
        # Store the results
        notesOut += f"""{newLine}• **{entryName}**: {code if code else ''}"""
      elif entryType == 'meta' or entryType == 'metaset':
        # Add the Meta Header
        if not metaOut:
          metaOut = f"""{newLine}**--Battlewide Meta--**"""
        # Store the results
        metaOut += f"""{newLine+opts if opts else ''}"""
        # If there's meta to change the name, display it up top too.
        if work.get('name'):
          finalName = f"""{Pick} - {work.last('name',None,str)}"""
      else: # thp, hp, move, goto, next, n, others
          if not extraOut:
            extraOut = f"""{newLine}**--Other Commands--**"""
          # Store the results
          extraOut += f"""{newLine}• {'**'+entryName+'**: ' if entryName else ''}**{entryType}** {code if code else ''}"""
  if Mode == 'view' and ViewOverride == 'view-numeric': # We want to view, but in numeric
    Mode = 'view-numeric'
  else:
    # Allows for others to use view code  
    if finalName: # Handle Special View Names
      Pick = finalName
    # Build our Output
    desctemp = f"""{desc if desc else ''}{newLine+newLine+attempted if attempted else ''}{newLine+newLine+"Examples:"+newLine+examples if examples else ''}{newLine+newLine+selectIntruction if selectIntruction else ''}{newLine+newLine+"__"+Pick.title()+"__" if Pick else ''}{entryOut.replace('|',pipeSlash) if entryOut else ''}{newLine + addsOut.replace('|',pipeSlash) if addsOut else ''}{newLine + effectsOut.replace('|',pipeSlash) if effectsOut else ''}{newLine + optsOut.replace('|',pipeSlash) if optsOut else ''}{newLine + notesOut.replace('|',pipeSlash) if notesOut else ''}{newLine + metaOut.replace('|',pipeSlash) if metaOut else ''}{newLine + extraOut.replace('|',pipeSlash) if extraOut else ''}""".replace(sepSlash, sep).replace(sepSingle,sepSingleSlash)
    #.replace(sep,sepSlash).replace(sepSingle,sepSingleSlash).replace(sepSingleSlash, sepSingle)

    if len(desctemp) <= 2048: # We're under limit - Do the display
      return f"""embed -title '{title}' -desc '{desctemp}' {"-f 'DisplayMode: "+Display+"'" if Display else ''} {foot}"""
    else: # Over Limit - Paging Time
      Mode = 'view-numeric'

if Mode == 'view-numeric' or Display == 'view-numeric':
  failed = False # Catches view specific issues
  commandOut = ""
  if not Display == 'view-numeric': # Handle only our errors, not fall-throughs
    title = AliasName+" - Battle Viewer"
  if not TryPick: # No Plan Name Provided
    failed = True
    if not Display == 'view-numeric':
      desc="You must specify a Plan Name."
      selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  elif not Pick: # No Plan Found
    failed = True
    if not Display == 'view-numeric':
      desc="Battle `"+TryPick.capitalize()+"` Not Found"
      selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  elif not RBattles[Pick]: # No Entries
    failed = True
    if not Display == 'view-numeric':
      desc="Battle has no monsters or commands."+newLine+"Add one with `"+AliasCommand+" add`"
      selectIntruction = "Select a Battle Plan:"+newLine+PlanList
  if not failed:
    if not Display: # We're viewing
      attempted = ""
      desc = ""
    # Paging stuff
    Battles = RBattles[Pick]
    commandList = newLine.join(['`'+str(i)+'`: '+x.replace(sep, sepSlash) for (i,x) in enumerate(Battles)])
    CommandSplit = commandList.splitlines(True)
    baseMessage = (f"""embed -title "{title}" -desc "{desc}
        Selected Battle Plan: `{Pick}`{newLine+'Attempted:'+newLine+'`'+fullCommand+'`' if attempted else ''}

        Commands:
        {newLine+newLine+"Examples:"+newLine+examples if examples else ''}{newLine+newLine+selectIntruction if selectIntruction else ''}" {foot}""")
    baseMessageSize = len(baseMessage)

    if len("".join(CommandSplit))+baseMessageSize > 2048: # Needs to be split up
      workCommand = CommandSplit
      pagingInfoSize = 70
      CommandStore = load_json('{}')
      Pages = load_json('[]')
      splitAt = 20
      while workCommand:
        while(len("".join(workCommand[:splitAt]))+baseMessageSize+pagingInfoSize > 2048):
          splitAt = splitAt - 1
        Pages.append(dump_json(workCommand[:splitAt]))
        workCommand = workCommand[splitAt:splitAt+20]
        splitAt = 20
      # Now write out the cache, display the first page
      commandOut = "".join(load_json(Pages[0]))
      CommandStore['Title'] = title
      CommandStore['HelperText'] = (newLine+newLine+"Examples:"+newLine+examples if examples else '')+(newLine+newLine+selectIntruction if selectIntruction else '')
      CommandStore['BodyText'] = desc+newLine+"Selected Battle Plan: `"+Pick+"`"+(newLine+newLine+attempted if attempted else '')+newLine+newLine+"Commands:"+newLine
      CommandStore['PageCount'] = int(len(Pages))
      CommandStore['CurrentPage'] = 1

      CommandStore.update(load_json('{\"Pages\": '+dump_json(Pages)+'}'))
      set_uvar(CacheOutputName,dump_json(CommandStore))

      pagingInfo = "**Page:** 1/"+str(CommandStore.get('PageCount'))+" `"+AliasCommand+" [n|p] Next|Previous Page`"
    else:
      commandOut = commandList
  return (f"""embed -title "{title}" -desc "{desc if desc else ''}{newLine+newLine+attempted if attempted else ''}{newLine+pagingInfo+newLine if pagingInfo else ''}{newLine+newLine+"Examples:"+newLine+examples if examples else ''}{newLine+newLine+selectIntruction if selectIntruction else ''}{newLine+newLine+"__"+Pick.title()+"__"+newLine+"Commands:"+newLine+commandOut.replace('|',pipeSlash) if commandOut else ''}" {"-f 'DisplayMode: "+Display+"'" if Display else ''} {foot}""")
</drac2>
