<drac2> # Battle Planner
args = &ARGS&
out = ""
newLine="\n"
plans=pick=""
Commands = ["view","begin","end", "delete", "clear"]
argNamesSingle = ["ac","conc","controller","desc","dur","end","h","hp","max","name","note","parent","rollhp","thp"]
argNamesMulti = ["adv/dis","attack","b","d","immune","neutral","resist","sb","t","vuln"]
argNamesMeta = ["dyn", "turnnotif", "deathdelete"]
argDescMeta = load_json('{"dyn": "Dynamic initiative; Rerolls all initiatves at the start of a round", "turnnotif": "Notifies the controller of the next combatant in initiative", "deathdelete": "Toggles removing monsters below 0 HP"}')
Source=get('BattlePlanLoc', 'Battles')
RBattles = load_json(get(Source, '{}'))
Battles = []
foot=f""" -footer '!bplan help | Battle Source: {Source} | v1.85 Made by Mahkasad#5996'"""
BP="Battle Planner"
title=f"""embed -title '{BP}'"""

# Assign the Mode
Mode=[x for x in args if x.lower() in Commands]
args.remove(args[0]) if args else ''

# Sort the Battles so we can get correct hits
# I hate this. We also fuzzy match in reverse
# This fixes the 'Arctic T1 82' 'Arctic T1 8' issue
if RBattles:
  Battles = list(RBattles)
  for i in range(len(Battles)-1):
    for j in range(i+1,len(Battles)):
      if Battles[i]>Battles[j]:
        temp = Battles[i]
        Battles[i] = Battles[j]
        Battles[j] = temp
  for plan in Battles:
    # Build the plan list
    plans = plans + f"""`\'{plan}\'`{newLine}"""
    # if we're doing something
    # exact match check
    if args and args[0].lower() == plan.lower():
      pick=plan
    # if we're doing something
    # fuzzy match check
    # search backwards to handle 'B 8' 'B 82' issue
    elif not pick and args:
      for plan in Battles[::-1]:
        if args and args[0].lower() in plan.lower():
          pick=plan

# Check for no inputs
if not Mode or (not Mode[0] == 'new' and not Battles):
  # No battles
  if not plans:
    return (f"""{title} -desc "Select a Battle Plan:
    No Battles Found. Add one with `!denc` or manually to `!uvar {Source}`.
    Addition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}""")
  else:
    return (f"""{title} -desc "The Battle Planner Tool is designed for interacting with Avrae's Combat Initiative and simplify preparing combats.
    
    For a list of commands see `!bplan help`
    
    Select a Battle Plan:{newLine + plans}" {foot}""")

elif Mode[0] == 'end':
  # End is simple, just call it
  return (f"""i end""")

elif Mode[0] == 'clear':
  
  if not args or not args[0]=='confirm': # Make sure 'clear confirm'
    return (f"""embed -title "{BP} - Clear All Battles" -desc "You must specify a confirmation to clear all battles:
    `!bplan clear confirm`" {foot}""")
  else: # Wipe out the uvar
    set_uvar(Source, "{}")
    return (f"""embed -title "{BP} - Clear All Battles" -desc "All Battles Cleared. Add more with `!denc`, `!battle`, or manually to {Source}" {foot}""")

elif Mode[0] == 'delete':
  if not args:
    return (f"""embed -title "{BP} - Delete Battle" -desc "You must specify a Battle Name to Delete.
    Select a Battle Plan:
    {plans}" {foot}""")
  if not pick:
    return (f"""embed -title "{BP} - Delete Battle" -desc "Battle `{args[0]}` Not Found
    {plans}" {foot}""")
  else:
    plans = plans.replace(f"""`\'{pick}\'`{newLine}""",'',1)
    RBattles.pop(pick)
    set_uvar(Source, dump_json(RBattles))
    return (f"""embed -title "{BP} - Delete Battle" -desc "Battle Deleted: `{pick}`
    
    Remaing Battles:
    {plans}" {foot}""")

if Mode[0] == 'begin':
  if not args: # No Battle Name Provided
    return (f"""embed -title "{BP} - Begin Battle" -desc "You must specify a Battle Name.
    Select a Battle Plan:{newLine + plans}" {foot}""")
  if not pick:  # No Plan Found
    return (f"""embed -title "{BP} - Begin Battle" -desc "Battle `{args[0]}` Not Found
    Select a Battle Plan:{newLine + plans}" {foot}""")
  if not RBattles[pick]: # No Entries
      return (f"""embed -title "{BP} - Begin Battle" -desc "__{pick}__
      
      Battle has no monsters or commands.
      Addition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}""")
    
  # Handle passing additional args to !i begin
  bargs = " ".join(args)
  # Prepare the complete set of commands
  command = f"""multiline{newLine}!i begin {bargs}"""
  count = total = 0
  limit = 19 # One less so we can store the more embed!
  moreSet = []
  for entry in RBattles[pick]:
    count,total = count + 1, total + 1
    if moreSet or count > limit:
      if count > limit: # We're too big, store current more and add a new more
        moreSet.append(moreCommand)      
        moreCommand = entry
      else: # Just add to the current more
        moreCommand = moreCommand + newLine + entry
    else: # Still in size
      command = command + newLine + entry
  # Store the More Commands if needed
  if moreSet: # TODO Build the More Embed
    moreName = f"""BPlan_More_{pick}"""
    set_uvar(moreName,json_dump(moreSet))
  # Call the Begin!
  return command

elif Mode[0] == 'view':
  if not args: # No Battle Name Provided
    return (f"""embed -title "{BP} - Battle Viewer" -desc "You must specify a Battle Name.
    Select a Battle Plan:{newLine + plans}" {foot}""")
  if not pick: # No Plan Found
    return (f"""embed -title "{BP} - Battle Viewer" -desc "Battle `{args[0]}` Not Found
    Select a Battle Plan:{newLine + plans}" {foot}""")
  if not RBattles[pick]: # No Entries
    return (f"""embed -title "{BP} - Battle Viewer" -desc "__{pick}__
    
    Battle has no monsters or commands.
    Addition of `new`, `edit`, `add`, and `remove` coming soon!" {foot}""")
  # No problems, Go through the entries
  work=entryOut=effectsOut=addsOut=notesOut=optsOut=metaOut=""
  for entry in RBattles[pick]:
    entryName = entryType = entryMod = effectName =''
    # Strip the init and type - !init <Type> <Code>
    entryType = entry.split(' ')[1]
    code=entry.replace(f"""!init {entryType} """,'').replace(f"""!i {entryType} """,'')

    # Check over the things that can add to init
    if entryType == 'madd': # madd| <name> <args>
      # Remove adv/dis from the name
      entryName = code.split(' -')[0].replace(' adv','').replace(' dis', '')
      code = code.replace(f"""{entryName} """,'')
      entryName= entryName.strip(r'\"\'')
    elif entryType == 'add': # add| <modifier> <name> <args>
      entryMod = code.split(' ')[0]
      # Take out the Type and Mod
      entryName = code.replace(f"""{entryMod} """,'').split(' -')[0]
      # and then remove adv/dis from the name
      entryName = entryName.replace(' adv','').replace(' dis', '')
      code = code.replace(f"""{entryMod}' '{entryName} """,'')   
      entryName= entryName.strip(r'\"\'')  
    elif entryType == 'effect': # effect| <target> <name> <args>
      sep = ''
      # Get if we are a "Wrapped String"
      if code.split(' -')[0] == '\'':
        sep = '\''
      elif code.split(' -')[0] == '\"':
        sep = '\"'
      if sep:
        entryName = code.split(sep)[0].strip(r'\"\'')
      else:
        entryName = code.split(' ')[0].strip(r'\"\'')
      code = code.replace(f"""{sep+entryName+sep} """,'')
      # Again for the Name of the Effect
      effectName = code.split(' -')[0]
      code = code.replace(effectName+' ','')
      entryName= entryName.strip(r'\"\'')
      effectName= effectName.strip(r'\"\'')
      entryName = f"""{entryName} - {effectName}"""
    elif entryType == 'note': # note| <name> <args>
      sep = ''
      # Get if we are a "Wrapped String"
      if code[0] == '\'':
        sep = '\''
      elif code[0] == '\"':
        sep = '\"'
      if sep:
        entryName = code.split(sep)[0].strip(r'\"\'')
      else:
        entryName = code.split(' ')[0].strip(r'\"\'')
      code = code.replace(f"""{sep+entryName+sep} """,'')
    elif entryType == 'opt' or entryType == 'opts': # opt,opts| <name> <args>
      entryName = code.split(' -')[0].replace(' adv','').replace(' dis', '')
      code = code.replace(f"""{entryName} """,'')
      entryName= entryName.strip(r'\"\'')
    elif entryType == 'meta' or entryType == 'metaset': # meta,metaset| <args>
      pass #Do Nothing here
    else: # skip the rest for now
      continue
    # Argparse it
    work = argparse(code)
    # Handle multiple number (-n)|group|place at (-p)
    # Only append x# if -n more than 1
    entryName = f"""{entryName}{' (x'+work.last('n',None,str)+')' if work.get('n') and work.last('n',None,int) > 1 else ''}{' ['+work.last('group')+']' if work.get('group') else ''}{' {'+(work.last('p',None,str) if not entryMod else str(entryMod))+'}' if work.get('p') else ''}"""

    # Extract all relevant args
    opts = [f"""-{x}: {work.last(x,None,str)}""" for x in argNamesSingle if work.get(x)]
    opts = opts + [f"""-{x}: {work.join(x,', ')}""" for x in argNamesMulti if work.get(x)]
    opts = opts + [f"""-{x}: {argDescMeta[x]}""" for x in argNamesMeta if work.get(x)]
    opts = " ".join(opts)

    if entryType == 'madd':
      if not entryOut:
        entryOut = f"""{newLine}**--Monsters--**"""
      # Store the results
      entryOut = entryOut + f"""{newLine}• **{entryName}**{newLine + opts if opts else ''}"""

    elif entryType == 'add':
      if not addsOut:
        addsOut = f"""{newLine}**--Placeholders--**"""
      # Store the results      
      addsOut = addsOut + f"""{newLine}• **{entryName}**{newLine + opts if opts else ''}"""

    elif entryType == 'effect':
      # Add the Effects Header
      if not effectsOut:
        effectsOut = f"""{newLine}**--Effects--**"""
      # Store the results
      effectsOut = effectsOut + f"""{newLine}• **{entryName}**{newLine + opts if opts else ''}"""

    elif entryType == 'opt' or entryType == 'opts':
      # Add the Notes Header
      if not optsOut:
        optsOut = f"""{newLine}**--Battlewide Opts--**"""
      # Store the results
      optsOut = optsOut + f"""{newLine}• **{entryName}**{newLine + code if code else ''}"""

    elif entryType == 'note':
      # Add the Notes Header
      if not notesOut:
        notesOut = f"""{newLine}**--Extra Notes--**"""
      # Store the results
      notesOut = notesOut + f"""{newLine}• **{entryName}**: {code if code else ''}"""

    elif entryType == 'meta' or entryType == 'metaset':
      # Add the Meta Header
      if not metaOut:
        metaOut = f"""{newLine}**--Battlewide Meta--**"""
      # Store the results
      metaOut = metaOut + f"""{newLine+opts if opts else ''}"""
      # If there's meta to change the name, display it up top too.
      if work.get('name'):
        pick = f"""{pick} - {work.last('name',None,str)}"""

  return f"""embed -title "{BP} - Battle Viewer" -desc "__{pick}__ {entryOut if entryOut else ''}{newLine + addsOut if addsOut else ''}{newLine + effectsOut if effectsOut else ''}{newLine + optsOut if optsOut else ''}{newLine + notesOut if notesOut else ''}{newLine + metaOut if metaOut else ''}" {foot}"""
</drac2>
